TODO:
* Refactor Heap, Graph, and cls2clq:
  - replace nip_clean_heap_item with general user-defined functionality
  + Heap should not depend on Graph: reform Heap
  + Some graph operations need to be reconsidered: e.g. add_variable
  + cls2clq.h -> niplists.h + nipgraph.h

* Refactorisation: replacing a lot of copy-paste code with these...
  - nip_variable_union(), 
  - nip_variable_isect(): search for clique_intersection, and
  - nip_mapper(): search for various clique reordering code...

* Use Git instead of CVS

* Check if the library is UTF-8 compatible...
  - hard byte length limit of some strings cuts UTF-8 chars?

* Document the code structure with UML "class" diagram
  - graph
  - heap
  - join tree
  - potential
  + lists
  + fileio -> string
  + variable

* Document the code structure with a call graph, where:
  - each function is a node
  - each call is represented by an edge (func A calls func B)
  - static and context-insensitive (the simple case) 
  - automated script to create DOT (GraphViz): codeviz?

* Refactor nip.c and jointree.c
  - functions that want collections of all variables and sepsets as parameters

* Figure out and test how nip_gather_joint_probability() works
  - probably has several errors in it

  
* Make it a library
  + makefile rules for static
  + makefile rules for a shared library
  - GNU libtool or Automake for portability???

* automated test scripts
  - test models and data
  - script with simple diff operations?

* the data file abstraction should be "lighter" and separate from model
  - Hide time_series and uncertain_series implementations better
    - more useful operations for them?
  - write_X() functions could take file id's instead of file names...
    (opening a file or other output would be users responsibility)

* clique.c could hide potential.c completely?
  - timeslice sepsets could be handled in clique.c

* Printing potential tables should be contained in potential.c
  - Problem: how to include comments about parent variable values?
  - Solution: do the stuff in clique.c..?

* Hugin Net parser should use a struct instead of global variables!

* Tiny addition to huginnet.y: potentialDeclaration without data
  (uniform potential) AND parents. Copy-paste the similar thing
  currently made for priors?

* Parse and preserve other fields specified in Hugin Net files
  (currently this program ignores them)
  - How to store potential-specific fields?
  - What are net{input/output}-fields?

* BUG: net parser segfaults if <symbols> is an empty list:
  "potential( A | ) { }" - it should report an error and quit

* print_model
  - writes an input file for graphviz/dot for automated visualization?

* "Viterbi" algorithm for the ML-estimate of the latent variables
  - It is a descendant of the algorithm called "max-product" or "max-sum"
  - another forward-like algorithm with elements of dynamic programming
  - To save huge amounts of memory, could the process use some kind of 
    "timeslice sepsets" for encoding the progress throughout time?
  - It has to have the backtracking ability...

* Leave-one-out program based on em_test and inftest...
  + loo_prediction_test
  + for each time series: predict the values of a given variable
      given a model learned from other series and 
      given data about the other variables
  - testing

* BUG: some DBN models work, equivalent static ones don't... WHY?
  - Does this happen only on MRF-like models? 
    Is it because of bad triangulation?
  - Should use_priors() be used automatically by reset_model() ?
  - Is the condition for entering priors really correct ?
  - Make sure priors get multiplied into the model only once!
    (previously they were treated like evidence and this wasn't a problem)

* A program for computing conditional likelihoods: likelihood.c
  + command line parameters:
    + "foo.net", the model
    + "bar.txt", the data
    + "D E F", at least one variable!
  + output: the likelihood value "p (d e f | a b c)"
  - the same for DBN models???

* Use separate structure for the first time step (or not?)
  - How to create the graph for it automatically?
  - How to use the new piece for inference in the first step?

* Implement some sort of structural learning algorithm?
  - NIP_potential_parents = "P1 P2 P3"; ?
  - There is a static set of edges and defined 
    set of possible additional edges in a graph
  - The graph has to be stored in the nip struct ?
    - nip struct       <=> net file
    - variable struct  <=> node() definition
    - potential struct <=> potential() definition???
  - What about graphs without any static edges?
    - Net file without any potential() definitions? (or only priors)
    - nip struct == a set of graphs and their clique trees?

* Get rid of copy-paste stuff in inference procedures... but how?

* Online forward_inference (+ refactor offline forward_inference?)

* Online fixed_lag_smoothing...



DONE:

* DONE: Refactor the list implementations
  - potentialList needs to be "hidden" better?
  - still massive amounts of copy-paste stuff... let it be?
  + Next time: make a general void* list or use C++

* DONE: Bug: evidence about variables without parents cancels the prior
  + Solved: Priors should not be entered as if they were evidence

* DONE: Solve circular dependency between Heap and clique!
  + heap.h uses clique.h, which does not depend on heap.h itself!

* DONE: A more dynamic Graph, allocated size vs. number of added nodes

* DONE: Check what potential and sepset do when dimensionality == 0
  + inverse_mapping can't be called when dimensionality == 0
  + p->size_of_data becomes 1 and the single number represents total sum

* DONE: Define enumeration types instead of a set of separate defines
  + typedef enum nip_direction_type {backward, forward} nip_direction;
  + typedef enum nip_error_code_enum { NO_ERROR = 0, ...} nip_error_code;
  + use nip_error_code instead of int

* Consistent conventions in naming functions, variables, and data structures?
  + make the naming conventions uniform, e.g. 
    state_names instead of statenames or stateNames
  + prefix everything with "nip" to simulate namespace
  + errorhandler.h -> niperrorhandler.h
  + lists.h -> niplists.h
  + fileio.h -> nipstring.h
  + variable.h -> nipvariable.h
  + potential.h -> nippotential.h
  + clique.h -> nipjointree.h
  + Heap.h -> nipheap.h
  + Graph.h -> nipgraph.h
  + parser.h -> nipparsers.h ?
  - nip.h ok?
  + convert -> nipconvert
  + em_test -> niptrain
  + gen_test -> nipsample
  + inftest -> nipinference
  + joint_test -> nipjoint
  + likelihood -> niplikelihood
  + map -> nipmap
  + loo_prediction_test -> nipbenchmark

* AN OLD PROBLEM:
  The time slice concept features some major difficulties because the
  actual calculations are done in the join tree instead of the graph. The
  program should be able to figure out how the join tree repeats itself and
  store some kind of sepsets between the time slices... Note that there can
  be only one sepset between two adjacent time slices, because the join
  tree can't have loops. This implies that the variables, which have links
  to the variables in the next time slice, should be found in the
  same clique.
  + It seems that Mr. Murphy has a solution: additional moralization of 
  "interface" variables to include them in a single clique.


--- Original huomioita.txt ---
Sekalaisia huomioita:

* voisi olla järkevää yhdistää myös moralisaatio find_cliquesiin
* pitäisikö tässä heappikin tehdä. lienee järkevintä.
* Variable.c:n new_variable näyttää työläältä
  * id tuntuu konseptina hankalalta, equal-vertailu kosahtaa NULLiin
    ja pointteri tekee saman (ellei sitten haluta muuttujille järjestystä...
    sen saisi Graphista. Tähän oli joku syy...)

* Myös Graph nähtävästi ei-pointteri. Mieti korjaus kun ei väsytä.
* potential copy_potential näyttää NULL-robustilta

* Potentiaalin choose_indices-funktiota kutsutaan jokaiselle potentiaalin
  alkiolle eli monta kertaa. Saattaisi olla tehokkaampaa tehdä ensiksi
  jonkinlainen "maski" ja käyttää sitä _ehkä_ tehokkaampana keinona 
  valita indeksit. -> ehkä kakkosversioon

16.1.2004 (Janne, Mikko)
* Taulukoita ei voi esitellä ilmoittamatta kokoa, eli
  tyyliin "int i[]" (pitää olla "int *i"). Taulukkoa ei myöskään voi
  esitellä tyyliin "int[] i" (tämä on javaa).

* Variable on nyt osoitintyyppi. Tarvittavat muutokset on
  periaatteessa tehty.
--

22.1.2004 (Mikko)
* Ovatko Graphin moralise-funktion parametrit järkevät? Pitääkö sille
  tosiaan antaa kopio alkuperäisestä verkosta. Eikö se voisi itse tehdä
  verkosta kopion ja palauttaa sen? Ehkä oli joku syy, miksi ei tehdä
  näin. Oliko?
--

23.2.2004 (Janne, Mikko)
* Alettiin ihmettelemään Bison-systeemeitä. Teemme seuraavaksi
  parserin, jolla saadaan malleja ja niiden parametreja luettua
  tiedostosta. Tällöin pääsemme ehkä jopa testaamaan tuotoksia...
--

16.3.2004 (Janne)
* Parserin määritteleminen ei ole aivan triviaalia. On hieman muokattava 
  mm. Variable-juttuja s.e. muuttujille voi asettaa tilojen nimet ja muut 
  parametrit helposti. Parseriin tulee tietorakenteet, joihin tiedoston 
  mukaisia muuttujia/nodeja tulee... Verkon, riippuvuuksien ja taulukoiden 
  parsettaminen vaikuttaa erityisen ikävältä. Tutkitaan...
--

24.5.2004 (Janne)
* Clique.c:ssä on nyt funktio create_Potential(...), jonka avulla voi 
  luoda ohjelmalle kelpaavan potentiaalin minkä tahansa muuttujajärjestyksen 
  mukaan järjestetystä taulukosta. Tämä on tarpeen, koska Huginin 
  tiedostoformaatissa esim. potentiaalin P(C | BD) "vähiten merkitsevä" 
  muuttuja on C, mutta ohjelmassamme oletetaan, että järjestys on esim. BCD.
--

26.5.2004
* Tarttis keksiä mihin muuttujia (Variable), klikkejä (Clique) ja sepsettejä 
  (Sepset) tallennetaan! Eli miten koodiamme hyväksi käyttävä ohjelma pääsee 
  käsiksi mihinkään ja miten parseri antaa tuotoksensa ulkomaailman nähtäväksi?
--

27.5.2004 (Mikko)
* Mikä ajatus on Variable.c:n funktiossa
  int variable_statenames(Variable v, char **states) ?
  Tuo ei näytä kovin paljon tekevän...
--

2.6.2004 (Janne)
* variable_statenames() mahdollistaa takin kääntämisen, jos joskus vaikka 
  vaihdettaisiin muistinvaraus strategiaa. Nyt taulukoita ei kopioida, 
  mutta vaarana on käytössä olevan muistin vapauttaminen tai uudelleen 
  käyttäminen merkkijonojen osalta.

* Mitäs mitäs... Meillä ei muuten taida olla semmoista kuin 
  "GLOBAL RETRACTION", vaikka jonkunlaiset valmiudet onkin. Tämä vain 
  tarkoittaa sitä, että mikään ei saisi olla mahdotonta 
  l. todennäköisyydeltään nollaa kun dataa syötetään sisään.
--

8.6.2004 (Janne)
* No voi hevon kettu. Ei sitten voinut Huginin net-tiedoston esittelyssä 
  kertoa kaikkia likaisia yksityiskohtia... Menee parseri pikkuisen 
  remonttiin, mutta onneksi tehtiin Bisonilla.
--

11.6.2004 (Janne ja Mikko)
* Klikeillä ei taida olla sepsettejä. Ei nimittäin etene distribute_evidence
  mihinkään. Nyt viikonloppua viettämään.
--

17.6.2004 (Janne ja Mikko)
* Melko monimutkainen Huginilla tehty verkko onnistutaan laskemaan oikein,
  JOS riippumattomien muuttujien jakaumaa ei yritetä asettaa .net -tiedoston
  potentiaaleilla. Tasajakauma (1 1 ... 1) siis toimii mutta muunlainen
  näköjään ei. Miten tällaiset tilanteet pitäisi hoitaa? enter_evidence ?
--

21.6.2004 (Janne ja Mikko)
* enter_evidencen käyttö riippumattomien muuttujien todennäköisyyksien
  initialisoinnissa toimii. Täytynee vielä tarkistaa, mitä sellaista
  oleellista eroa initialisen ja enter_evidencen välillä on, joka aiheuttaa
  virheellisiä tuloksia ensin mainitun kanssa. Toki Variablen likelihood
  pitää alustaa, mutta sen alustamattomuus ei liene syyllinen
  esimerkkitapauksen vääriin tuloksiin.
--

9.7.2004 (Janne ja Mikko)
* Jouduttiin menemään muutoksissa takaisinpäin kolmisen tuntia. Yritettiin
  pikaisesti integroida "Clique unmark" collect_evidenceen,
  distribute_evidenceen yms. Kone meni rikki, minkä takia paluu vanhaan.
  Täytyy tehdä loman jälkeen paremmin.
--

3.8.2004 (Mikko)
* Ajateltiin eilen, että ei kannata vielä yhdistää "Clique unmark" -hommaa,
  koska koko ohjelman rakenne on vähän hakusessa. Jonkinlainen "nip"-rakenne
  olisi kai hyvä olla. Mutta mitä seuraavaksi?
--

5.8.2004 (Janne ja Mikko)
* Mietitään, minkälaisia rakenneuudistuksia tehdään. Parasta olisi, jos homma
  saataisiin yksisuuntaiseksi, eli uusi "nip"-systeemi tulee vanhan päälle.

* nip.c:hen joku "parse_model" tms. joka käynnistää parserin ja kopioi
  muuttujalistan ja klikkitaulukon (ainakin) malliin. Palauttaa mallin.

--- end of huomioita.txt ---
