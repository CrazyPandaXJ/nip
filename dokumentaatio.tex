% NIP - project documentation
% Mikko Korpela, Antti Rasinen, Janne Toivola 2004
% $Id: dokumentaatio.tex,v 1.11 2004-08-30 11:20:36 jatoivol Exp $

\documentclass[12pt,a4paper]{report}
%\bibliographystyle{unsrt}
\setlength{\topmargin}{0mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\textheight}{22cm}
\setlength{\textwidth}{16cm}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{tocbibind}
\usepackage{fancyvrb}
%\newcommand{\argmax}{\mathrm{argmax}}
%\newcommand{\argmin}{\mathrm{argmin}}
%\newcommand{\define}{\stackrel{\mathrm{def}}{=}}

%--------------------
% Place this in the preamble of your LaTeX file:
% (c) Jaakko Hollmen, 2002

\usepackage{ifthen}

% Declare the variable doublespaced
\newboolean{doublespaced}

% Comment one of the following lines to either select
% doublespaced or singlespaced:
\setboolean{doublespaced}{false}
%\setboolean{doublespaced}{true}

\ifthenelse{\boolean{doublespaced}}
{
  % Double spaced text if variable "doublespaced" is true:
  \renewcommand{\baselinestretch}{1.5}
  \normalsize % necessary to execute the previous thing
}
{
  % This is to be executed if doublespace is false:
  % else = do nothing
}
%--------------------

\title{NIP}
\author{Antti Rasinen}
\author{Mikko Korpela 54919L}
\author{Janne Toivola 55173U}
\begin{document}

\pagestyle{empty}
\setlength{\parindent}{0mm}
\setlength{\parskip}{3mm}

\large
\textbf{The NIP project}\\

\vspace{45mm}

\begin{centering}
\huge
\textbf{System description}\\ % Any better names for this?
\end{centering}

\parbox{5cm}{\ }
\parbox{1em}{\vskip8cm}

\normalsize
\vspace{5mm}
\begin{tabbing}
The Team:\= Antti Rasinen\\
         \> Mikko Korpela\\
         \> Janne Toivola\\
\vspace{5mm}

\end{tabbing}
%----------------------
Date: \today
%----------------------
\eject\newpage

\pagestyle{plain}

\tableofcontents

%\newpage
%
%\listoffigures


% Reminder about the style so far: 
% - C data types     {\it unsigned long}
% - code examples    \verb+this = is_an(example);+
% - file names       \verb+filename.txt+
% - defined stuff    \textbf{A_DEFINED_VALUE}
% - parameter names  \textbf{parameter}
% ...
% Try to keep it consistent...


\newpage
\chapter{General description}

Some introduction here...

\section{Overview}

Some outline of the system...

\newpage
\chapter{Subsystem descriptions}
\section{Variables}
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}

\subsubsection{The data structure}
The data type {\it Variable} defined in \verb+Variable.h+ is a pointer 
to a struct which has the following fields: 
\begin{description}
\item[symbol] is a short string used to identify the variable. Maximum
length is defined as \textbf{VAR\_SYMBOL\_LENGTH} in
\verb+Variable.h+. To ensure the correct operation of the system, the 
symbol should be unique.

\item[name] is a little longer name to describe the variable: it is
called {\it label} in the Hugin net files. This is NOT used for 
identification of the variables and it doesn't need to be unique. 
The maximum length is defined as \textbf{VAR\_NAME\_LENGTH} in 
\verb+Variable.h+.

\item[statenames] is an array of strings containing names for all
possible states of the variable. The identification of data relies on
these strings. The size of the statenames array i.e. number of
strings should be the same as the number of states indicated by
cardinality field described below.

\item[cardinality] is a positive integer which tells how many states
the variable can have. It plays an important role in all calculations
so it better be correct: the value is not meant to be altered.

\item[id] is an {\it unsigned long} used for identification inside the
system. It is set automatically by the \verb+new_variable+ function
and should not be tampered after that.

\item[likelihood] is a {\it double} array describing the probability
distribution of the states of the variable. It is used only for
entering evidence into the system and likelihood arrays of the latent
variables remain filled with ones. Size of the array equals
cardinality, of course.

\item[previous] is used to describe the repetitive structure in
timeslice models. It is a pointer to the variable which this variable
will replace in previous timeslice. The pointer is {\it NULL} if the
model has no repetitive structure.

\item[next] is a same kind of pointer as \textbf{previous} above, but
this one tells which variable will be replaced in the next timeslice.
The \textbf{previous} and \textbf{next} pointers should be symmetrical
i.e. if \verb+a->next == b+ then \verb+b->previous == a+.
\end{description}

\verb+Variable.h+ provides also data types for implementing lists of
variables. Both \verb+varlink+ and \verb+Variable_iterator+ are
pointers to structs which contain following fields:
\begin{description}
\item[data] is the variable (i.e. pointer to a variable struct) 
contained by the list element.

\item[fwd] is a pointer to the next element in the list or {\it NULL}
at the end of the list.

\item[bwd] is a pointer to the previous element in the list or 
{\it NULL} at the beginning of the list.
\end{description}
Variable iterators are meant to be used the same way as list iterators
in Java: you can get the next element contained by the list by just 
calling \verb+next_Variable(iterator)+. On the other hand, iterators
are NOT meant to be the only reference to a list because it will
advance in the list, pointing always to the next element and eventually
be a null pointer.


\subsubsection{The functions}
The functions provided in \verb+Variable.c+ are
%The interface + how the stuff works...
\begin{description}
\item[new\_variable(symbol, name, states, cardinality)] creates a
variable identified with the \textbf{symbol} string. The \textbf{name} 
string will be copied as the name field of the new variable. Both the 
\textbf{symbol} and \textbf{name} strings may be truncated to the 
allowed length. The states of the new variable will be named according 
to the given string array \textbf{states}. All the given strings are 
copied, so remember to free them after they become useless.

\item[copy\_variable(v)] returns an exact copy of the
variable~\textbf{v}. Note that also the id~field is copied and 
consequently there may not be two copies of the same variable in the 
same model.

\item[free\_variable(v)] frees the memory allocated for the
variable~\textbf{v}. 

\item[equal\_variables(v1, v2)] returns 0 if either of the variables
are null. Otherwise it will tell if the variables have equal id fields
or not.

\item[get\_id(v)] will return the unsigned long id field of the 
variable~\textbf{v}.

\item[get\_symbol(v)] returns the symbol of the variable~\textbf{v}. It
will not make a copy of the string so don't mess with it.

\item[get\_stateindex(v, state)] tells the place of the string
\textbf{state} in the state name array of the
variable~\textbf{v}. This index can be used to interpret various
arrays describing probability distributions. 

\item[total\_num\_of\_vars()] is used only to aid the Hugin net file
parser to return the total number of newly created variables. All 
the variables created with \textbf{new\_variable} are accumulated 
in a list and this function can tell the size of that list.

\item[get\_first\_variable()] gives the first element in the list
of newly created variables mentioned above.

\item[get\_last\_variable()] gives the last element in the list
of newly created variables mentioned above.

\item[reset\_Variable\_list()] will replace the list of recently created
variables with {\it NULL} and set the size of the list to zero. This
is used only for resetting the list after copying the list pointer
to a new model. Otherwise all the models would share the same list of
parsed variables.

\item[next\_Variable(it)] will give the next variable pointed by the
variable iterator~\textbf{it} and advance the pointer to the next
variable in the list. The function returns {\it NULL} if the iterator
runs out of variables.

\item[get\_parser\_variable(symbol)] aids the net file parser to find a
variable, identified by the \textbf{symbol} string, in the list of newly
created variables.

\item[get\_variable(it, symbol)] searches the
variable iterator~\textbf{it} for a variable identified by the string
\textbf{symbol}. The iterator will be used by the function, so it will
not be pointing to the beginning of any lists anymore.

\item[update\_likelihood(v, likelihood)] will set the likelihood array
of variable~\textbf{v} according to the given double array 
\textbf{likelihood}. Size of the given array should be the same 
(or more) than the cardinality of the variable.

\item[reset\_likelihood(v)] fills the likelihood array of the
variable~\textbf{v} with ones. This means that the likelihood of the
variable states will be uniform.

\item[number\_of\_values(v)] returns the cardinality of the
variable~\textbf{v}. It is the exact number of states the variable has
and will always have.
\end{description}


\subsection{Other possibilities}
The Hugin net file parser is made with Bison and consequently the 
\verb+yyparse+ function is not able to return a list of variables etc. 
This makes it awkward to pass the results of parsing to the rest of the
program. Our solution is to create a list of parsed variables in
\verb+Variable.c+ but it could also be at \verb+parser.c+ in order to
avoid having weird functions like \verb+get_parser_variable+.


\newpage
\section{Graphs}
\subsection{General}

The idea and mathematical formulas...


\subsection{The functionality description}
%The interface + how the stuff works...
\subsubsection{The data structures}

\subsubsection{The functions}


\subsection{Other possibilities}

How the stuff could work also...


\newpage
\section{Potentials}
\subsection{General}

The idea and mathematical formulas...


\subsection{The functionality description}
%The interface + how the stuff works...
\subsubsection{The data structure}
The data type {\it potential} defined in \verb+potential.h+ is a
pointer to a struct which contains the following fields:
\begin{description}
\item[size\_of\_data] is an {\it integer} telling the total number of 
elements in the potential. It must be the product of all the elements 
in the \textbf{cardinality} array (or one if the number of variables 
equals zero).

\item[cardinality] is an array of {\it integers}. The integers are the
cardinalities of each variable the potential is related to. Thus the
size of the array must be the same as the number of variables. Also
the order of the cardinality array is significant because the
variables are assumed to have a certain order.

\item[num\_of\_vars] is an {\it integer} which tells the number of variables
associated with the potential.

\item[data] is the {\it double array} describing a probability
distribution of the associated variables. The size of this array is in
the \textbf{size\_of\_data} field. The data in the array is arranged
according to the order of the corresponding variables: the variable
which has its cardinality first in the \textbf{cardinality} array is
considered least significant in the sense of placing a value in the
\textbf{data} array. 

\end{description}


\subsubsection{The functions}
The functions provided for manipulating {\it potentials} are placed in
potential.c and are as follows:
\begin{description}
\item[make\_potential(cardinality, num\_of\_vars, data)] creates a
potential struct according to the parameters and returns a pointer
to it. The resulting potential will have its cardinalities of
variables set according to the given \textbf{cardinality} array by
copying the elements in it. The number of associated variables is
given as the integer \textbf{num\_of\_vars}. 

The \textbf{data} parameter can be a null pointer or a {\it double 
array} of the size equal to the product of the cardinalities of the 
variables. In case of a null pointer, the potential will be
initialised to uniform distribution. Otherwise the contents of 
the \textbf{data} array in the potential struct will be copied from
the given \textbf{data} array.

\item[free\_potential(p)] frees the memory allocated for the
potential~\textbf{p}. 

\item[copy\_potential(source, destination)] copies the distribution
contained in the \textbf{source} potential to the given
\textbf{destination} potential. Note that both of the potentials must
be already existent and otherwise equal. Use the 
\textbf{make\_potential} function if you need an entire new copy of 
a potential.

\item[get\_pvalue(p, indices)] retrieves the possibly non-normalised
probability of the configuration of variables, described by the integer 
array \textbf{indices}, from the potential~\textbf{p}. The
\textbf{indices} array tells which value each of the associated
variables are assigned: $n-1$ in the array corresponds to the $n$:th 
value of the variable. The \textbf{indices} must be in the same order
as the corresponding variables and their cardinalities in the
potential~\textbf{p}. 

\item[set\_pvalue(p, indices, value)] sets a {\it double}
\textbf{value} in the potential~\textbf{p} the same way as 
\verb+get_pvalue(p, indices)+ retrieves it. (See the description above.)

\item[inverse\_mapping(p, flat\_index, indices)] transforms a
so-called flat index into the {\it integer array} \textbf{indices} according 
to the potential~\textbf{p}. A flat index is an index used for addressing
data in the potential and is therefore an integer between \verb+0+ and 
\verb+p->size_of_data - 1+ inclusive. Shortly, this function is made for
finding out which configuration of states of the variables corresponds
to each element in the potential. Note that the \textbf{indices} array 
is not allocated by the function.

\item[general\_marginalise(source, destination, source\_vars)] is one
of the most useful functions since it computes the marginalisation
i.e. a sum over the variables indicated by the given {\it integer
array} \textbf{source\_vars} and places the result in the given
\textbf{destination} potential. To make any sense, the number of
associated variables in \textbf{source} must be greater than in
\textbf{destination}. The implementation assumes that the variables 
common to the potentials are in the same order. Consequently, all the 
variables in a system must have a total and static ordering in
order to keep all the sets of variables shared by neigbouring clique
potentials in order.

The {\it integer array} \textbf{source\_vars} indicates which
variables are marginalised away. It consists of indices ranging from
\verb+0+ to \verb+source->num_of_vars - 1+ inclusive. The array
must be arranged in ascending order and the size must equal the
difference in the numbers of associated variables in the potentials. 
Simply, a zero in the array tells the function to marginalise over the 
first variable. Note that the result is not normalised.

\item[total\_marginalise(source, destination, variable)] can be used
for finding out the probability distribution of a single variable
according to the \textbf{source} potential. The function is similar to
the \textbf{general\_marginalise} but instead of telling which
variables to marginalise away, the user must indicate which
variable is left unmarginalised. The parameter \textbf{variable} is 
an {\it integer} ranging from \verb+0+ to\\
\verb+source->num_of_vars - 1+ inclusive. Zero indicates the first
variable in the potential.

Another difference arises from the fact that the probability 
distribution of a single variable fits into a one-dimensional array. 
The place to put the resulting {\it double array} 
(\textbf{destination}) is given to the function as one of the
parameters. Size of the array must be equal (or greater) to the
cardinality of the desired variable, so remember to allocate one
before calling this function. Note that the result is not normalised.

\item[update\_potential(numerator, denominator, target, extra\_vars)] 
implements the multiplication of potentials. The function simply
multiplies the elements of the \textbf{target} potential with the
corresponding elements in the \textbf{numerator} potential. At the
same time, the function is able to divide the \textbf{target}
potential with the optional \textbf{denominator} potential. If no
division is needed, \textbf{denominator} can be {\it NULL}.
The \textbf{numerator} and \textbf{denominator} potentials are left
unchanged by the function.

The function is made for multiplying the a clique potential with the 
old and new sepset potentials. It is assumed that the variables
associated with the multiplier potentials are a subset of the
variables associated with the target potential. Thus the user needs to
indicate which of the variables in the target potential are not
associates with the multiplier potentials. This is achieved with the
fourth parameter \textbf{extra\_vars} which is an {\it integer array}. 
The array must be in ascending order. For example, a zero in the array 
indicates that the first variable of the target potential is not
amongst those associated with the multiplicand potentials.

\item[update\_evidence(numerator, denominator, target, var)] is made
for multiplying potentials with probability distributions of a single
variable. The potential to be manipulated is given as the
\textbf{target} parameter. It is multiplied by the given {\it double
array} \textbf{numerator} which usually represents the probability
distribution of a variable. The \textbf{denominator} is a similar 
{\it double array} used for dividing the \textbf{target} potential. 
If not needed, the \textbf{denominator} can be {\it NULL}.

Typically the function is used for multiplying evidence into a clique 
potential and dividing with possible old evidence. The variable, whose 
distribution is to be passed into the potential, must be indicated 
with the \textbf{var} {\it integer}. E.g. a zero tells the function 
that the evidence is about the first variable associated with the potential.

\item[init\_potential(probs, target, extra\_vars)] is essentially the
same as the \\ \textbf{update\_potential} function. It is meant for
multiplying the \textbf{target} potential with the given
\textbf{probs} potential. If the potentials are similar, i.e. they
have the same associated variables, the \textbf{extra\_vars} parameter 
should be {\it NULL}. Otherwise \textbf{extra\_vars} is an 
{\it integer array} indicating which of the variables associated with
the target potential are not associated with the multiplier potential.

\item[print\_potential(p)] is mainly for debugging purposes. It prints 
the contents of the potential~\textbf{p} to the standard output.

\end{description}


\subsection{Other possibilities}
There are several ways of implementing the calculations of the potentials
without keeping the corresponding variables in a certain order. This
could be achieved by using an integer array to remap the order of the
variables instead of telling which are not included and assuming that
the rest of the variables are in the same order in both potentials.


\newpage
\section{Join trees} % Cliques and sepsets
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}
The files \verb+Clique.h+ and \verb+Clique.c+ provide data types and 
functions for operating with sepsets and cliques. Together these form
the concept known as join tree. In the NIP system, a join tree is
merely an array of cliques which in turn have references to all the
necessary sepsets.

\subsubsection{The data structures}
\verb+Clique.h+ provides data types {\it Sepset}, {\it Sepset\_link}, 
and {\it Clique}. {\it Sepset} is a pointer to a struct which has the
following fields:
\begin{description}
\item[old] is older of the two last {\it potentials} passed via the sepset.

\item[new] is the last {\it potential} passed via the sepset.

\item[variables] is an {array of Variables}. These are the variables
associated with the sepset. They are in the same order as their
cardinalities in the potentials \textbf{old} and \textbf{new}. 
The number of the variables can be found in either of the potentials 
\textbf{old} and \textbf{new}.

\item[cliques] is an {array of Cliques}. The references to the
adjacent cliques are there. The size of the array is always two
because of the nature of sepsets.
\end{description}

The data type {\it Sepset\_link} provides an implementation for lists
of {\it Sepsets}. It is a pointer to a struct containing
\begin{description}
\item[data] is a so-called {\it void pointer} because of the order of
definitions. (You can't really define a list of sepsets before you
have defined sepsets. Sepsets can't be defined before cliques and
cliques can't be defined before lists of sepsets.) When the list of
sepsets is used, the \textbf{data} field has to be cast to the 
{\it Sepset} type. 

\item[fwd] is the next {\it Sepset\_link} in the list or {\it NULL} at
the end of the list.

\item[bwd] is the previous {\it Sepset\_link} in the list or 
{\it NULL} at the beginning of the list.

\end{description}

The data type {\it Clique} is a pointer to a struct containing all the
necessary for working with cliques. The fields are
\begin{description}
\item[p] is the clique {\it potential}

\item[original\_p] is the original clique {\it potential} initialised
according to the parameters of the model

\item[variables] is an {\it array of Variables}. These are the
references to the variables associated with the clique. They are in
the same order as their cardinalities in the potential~\textbf{p}.
The number of variables can be found in the potential~\textbf{p}.

\item[sepsets] is a {\it Sepset\_link} i.e. either {\it NULL} or a
list of sepsets. The list contains the references to the adjacent sepsets.

\item[num\_of\_sepsets] is the number of adjacent sepsets.

\item[mark] is an {\it integer} used as a flag by various algorithms. For
example a depth-first search and the propagation of evidence uses the 
\textbf{mark} field to identify the cliques which have already been 
handled.

\end{description}


\subsubsection{The functions}
The file \verb+Clique.c+ provides the following functions
\begin{description}
\item[make\_Clique(vars, num\_of\_vars)] creates a {\it Clique}. The
associated variables are given as the {\it Variable array}
\textbf{vars} and the number of the variables as the {\it integer} 
\textbf{num\_of\_vars}. A shallow copy of the array is made, so
remember to free it (but not the contents). The clique will not have 
any adjacent sepsets initially. Sepsets must be added separately.

\item[free\_Clique(c)] frees the memory allocated by a the 
{\it Clique}~\textbf{c}. It will not free the memory allocated for 
the corresponding {\it Variables}, but all the adjacent {\it Sepsets} 
are freed and removed automatically so that rest of the join tree 
remains valid. Note that freeing an entire join tree can be done by 
calling this function for every clique.

\item[add\_Sepset(c, s)] adds the {\it Sepset} \textbf{s} to the 
{\it Clique}~\textbf{c}. Remember to add the sepset to both adjacent
cliques and never add a sepset to the same clique twice.

\item[make\_Sepset(variables, num\_of\_vars, cliques)] creates a {\it
Sepset}. The associated variables are given as the {\it Variable
array} \textbf{variables} and the size of the array as the {\it
integer} \textbf{num\_of\_vars}. Both adjacent cliques must be given
as an {\it array of Cliques} (\textbf{cliques}). This usually means that
the {\it Cliques} must be created before the {\it Sepsets}.
Note that a shallow copy of the parameter arrays is made, so freeing 
the arrays after calling the function is up to the user.

\item[free\_Sepset(s)] just frees the memory allocated for the {\it
Sepset} \textbf{s}. This is called automatically by
\textbf{free\_Clique} so usually this function is needed only for
freeing possible useless {\it Sepsets} which are not included in the 
join tree.

\item[create\_Potential(variables, num\_of\_vars, data)] can help if
you need to create potentials out of {\it double arrays} like 
the \textbf{data} parameter. The function creates a {\it potential} 
which has its data arranged correcty in order to work with the
system. To rearrange the data correctly, the function needs to know 
the order of the corresponding variables. This is achieved by 
specifying the {\it Variable array} \textbf{variables} and the size 
of it as the {\it integer} \textbf{num\_of\_vars}. 

The most important thing is to have the {\it Variables} array in the 
same order as the \textbf{data} array is thought to be arranged. 
For example, the potentials specified in the Hugin net files have the 
child variable as the least significant one: the value of the variable 
has the least effect on the placement of the data. Thus the child
variable should be the first in the array. Note that for some reason 
the first parent variable specified in the Hugin net files should be 
the last in the \textbf{variables} array, and the last parent should
be the second right after the child variable.

\item[unmark\_Clique(c)] resets the mark in the {\it
Clique}~\textbf{c}. Note that this has to be done for every clique 
before calling \textbf{distribute\_evidence} or 
\textbf{collect\_evidence}.

\item[clique\_num\_of\_vars(c)] tells how many associated variables the 
{\it Clique}~\textbf{c} has.

\item[sepset\_num\_of\_vars(s)] tells how many associated variables the 
{\it Sepset}~\textbf{s} has.

\item[distribute\_evidence(c)] implements the algorithm which spreads 
the evidence entered in to the cliques away from the given 
{\it Clique}~\textbf{c}. See \cite{procedural_guide} page 21 for
details. 

\item[collect\_evidence(c1, s12, c2)] implements the algorithm which 
collects evidence from the subtree rooted in the given {\it
Clique}~\textbf{c2} and passes the evidence to the {\it
Clique}~\textbf{c1}. The {\it Sepset}~\textbf{s12} is the sepset
between the two cliques. The function is recursive and is usually
used like this: \verb+collect_evidence(NULL, NULL, c);+ where \verb+c+
is some {\it Clique}. This causes the evidence to be collected from
the entire join tree.

\item[initialise(c, child, parents, p)] is used for entering the
quantitative parameters of the model into the join tree. This function
initialises the {\it Clique}~\textbf{c} with the given {\it
potential}~\textbf{p}. The initialisation ensures that the parameters
are not reset by the \textbf{global\_retraction} function. Note
that~\textbf{p} should be a valid {\it potential} i.e. the data
contained by it should be correctly arranged and the number of
variables specified in it should equal to the number of parent
variables plus one (the child).

Since the clique to be initialised can be associated with more
variables than are associated with the potential, the user must
specify the \textbf{child} {\it Variable} and the {\it array of 
variables} which contain the \textbf{parents}. The order of the
variables in the \textbf{parents} array is not relevant and the 
array is not needed after the function has executed.

\item[marginalise(c, v, r)] is one of the most useful functions
because it finds out the probability distribution of the {\it
Variable}~\textbf{v} according to the {\it Clique}~\textbf{c} and
writes it into the {\it double array}~\textbf{r} (as in
\textbf{r}esult). The array must be allocated before the function is
called and the size must be at least \verb+v->cardinality+. 
Note that the result is NOT normalised.

\item[normalise(result, array\_size)] simply normalises the {\it
double array} \textbf{result}. After the function has executed, sum of
the elements in the array will be one, unless it's filled with zeros. 
If the array is full of zeros, it is left unchanged. The size of the
array must be specified as the {\it integer} \textbf{array\_size}.

\item[global\_retraction(vars, cliques, num\_of\_cliques)] resets the 
clique potentials to the state they had after the initialisation and 
enters the most recent evidence into the cliques. Thus the join tree
consisting of the cliques is left at an inconsistent state and you may
want to execute the global propagation consisting of 
\textbf{collect\_evidence} and \textbf{distribute\_evidence}. 

This function is needed for retracting evidence in some cases. To
achieve this, the user must enter the wanted evidence into the
variables and run \textbf{global\_retraction}. The 
{\it Variable\_iterator} \textbf{vars} (list of all the variables) and 
a {\it Clique array} \textbf{cliques} must be specified. Also the
number of the cliques has to be given to the function as the {\it
integer} \textbf{num\_of\_cliques}.

\item[enter\_observation(vars, cliques, num\_of\_cliques, v, state)] 
is made for incorporating hard evidence into a join tree. The observed
state of the {\it Variable}~\textbf{v} is given as a {\it string} named
\textbf{state}. The function needs also the {\it Variable\_iterator}
\textbf{vars}, {\it Clique array} \textbf{cliques} and the size of it
as the {\it integer} \textbf{num\_of\_cliques}. The reference
\textbf{vars} to the list of all variables is needed because of the
possible global retraction. The function \textbf{global\_retraction}
is called automatically if needed.

\item[enter\_i\_observation(vars, cliques, num\_of\_cliques, v, index)]
is made for entering an observation as an {\it integer} into a join
tree. This is equal to the function \textbf{enter\_observation} but
instead of telling the observation as a string, the user should encode
the observation as the {\it integer} \textbf{index}. A zero
corresponds to the first state of the variable defined in the Hugin
net file. (See the \textbf{get_stateindex} function also.)

\item[enter\_evidence(vars, cliques, num\_of\_cliques, v, evidence)]
is made for entering soft evidence into a join tree. (Note that hard
evidence is only a special case of soft evidence.) The function is
similar to the \textbf{enter\_observation} and
\textbf{enter\_i\_observation} functions above but instead of
describing a single state, the user must specify a probability
distribution as the {\it double array} \textbf{evidence}. The array is
assumed to be normalised.

\item[find\_family(cliques, num\_of\_cliques, variables, num\_of\_vars)]
tries to find a {\it Clique} which contains all the variables (or
more) specified in the {\it Variable array} \textbf{variables}. The 
number of variables has to be given as the fourth parameter 
\textbf{num\_of\_vars}. The function returns {\it NULL} if there are
no suitable cliques in the specified {\it array of Cliques} 
(\textbf{cliques}) within the given size \textbf{num\_of\_cliques}.

\item[find\_sepsets(cliques, num\_of\_cliques)] creates and inserts 
the sepsets between the {\it Cliques} specified in the array 
\textbf{cliques}. The size of the array must be given as the 
{\it integer} \textbf{num\_of\_cliques}. This function is meant to be
used only once after all of the cliques have been created. 
Consequently, it is not intended for repairing partially created 
join trees.

\item[print\_Clique(c)] is meant for debugging purposes. It prints the
symbols of the variables associated with the {\it Clique}~\textbf{c}
to the standard output.

\item[print\_Sepset(s)] is meant for debugging purposes. It prints the
symbols of the variables associated with the {\it Sepset}~\textbf{s}
to the standard output.

\item[clique\_intersection(cl1, cl2, vars, n)] finds out which
variables are common to the specified {\it Cliques}~\textbf{cl1}
and~\textbf{cl2}. The parameter \textbf{vars} is a {\it pointer to an
array of Variables} and the array will contain the found variables 
after the execution. The size of the array is written to the place 
pointed by the {\it integer pointer}~\textbf{n}. The resulting array
is allocated by the function and it should be freed by the user.

\item[get\_num\_of\_cliques()] 

\item[get\_cliques\_pointer()]

\item[set\_num\_of\_cliques(n)]

\item[reset\_Clique\_array()]

\end{description}


\subsection{Other possibilities}

How the stuff could work also...


\newpage
\section{The Hugin net file parser}
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}

The interface + how the stuff works...

\subsection{Other possibilities}

How the stuff could work also...


\newpage
\section{The timeslice handler} % Some system which handles time series?
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}

The interface + how the stuff works...

\subsection{Other possibilities}

How the stuff could work also...



\newpage
\chapter{System analysis}
\section{The parser}

\section{The graph}

\section{The join tree}

\section{The timeslice-monster}


\newpage
\chapter{Comments}


\newpage
%\appendix
%\newpage
%\bibliography{dokumentaatio}

\end{document}
