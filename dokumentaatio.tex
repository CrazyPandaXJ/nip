% NIP - project documentation
% Mikko Korpela, Antti Rasinen, Janne Toivola 2004
% $Id: dokumentaatio.tex,v 1.30 2004-09-27 13:58:48 jatoivol Exp $

\documentclass[12pt,a4paper]{report}
\bibliographystyle{unsrt}
\setlength{\topmargin}{0mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\textheight}{22cm}
\setlength{\textwidth}{16cm}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{tocbibind}
\usepackage{fancyvrb}
\usepackage{times}
%\newcommand{\argmax}{\mathrm{argmax}}
%\newcommand{\argmin}{\mathrm{argmin}}
%\newcommand{\define}{\stackrel{\mathrm{def}}{=}}


% Reminder about the style so far: 
% - C data types     {\it unsigned long}
% - code examples    \texttt{this = is_an(example);}
% - file names       \texttt{filename.txt}
% - defined stuff    \textbf{A_DEFINED_VALUE}
% - parameter names  \textbf{parameter}
% ...
% Try to keep it consistent...

\newcommand{\cdatatype}[1]{{\it #1}}
\newcommand{\examplecode}[1]{\texttt{#1}}
\newcommand{\cfilename}[1]{\texttt{#1}}
\newcommand{\cdefine}[1]{\textbf{#1}}
\newcommand{\cparameter}[1]{\textbf{#1}}
\newcommand{\cstructfield}[1]{\textbf{#1}}
\newcommand{\cfunction}[1]{\texttt{#1}}


%--------------------
% Place this in the preamble of your LaTeX file:
% (c) Jaakko Hollmen, 2002

\usepackage{ifthen}

% Declare the variable doublespaced
\newboolean{doublespaced}

% Comment one of the following lines to either select
% doublespaced or singlespaced:
\setboolean{doublespaced}{false}
%\setboolean{doublespaced}{true}

\ifthenelse{\boolean{doublespaced}}
{
  % Double spaced text if variable "doublespaced" is true:
  \renewcommand{\baselinestretch}{1.5}
  \normalsize % necessary to execute the previous thing
}
{
  % This is to be executed if doublespace is false:
  % else = do nothing
}
%--------------------

\title{NIP}
\author{Antti Rasinen}
\author{Mikko Korpela 54919L}
\author{Janne Toivola 55173U}
\begin{document}

\pagestyle{empty}
\setlength{\parindent}{0mm}
\setlength{\parskip}{3mm}

\large
\textbf{The NIP project}\\

\vspace{45mm}

\begin{centering}
\huge
\textbf{System description}\\ % Any better names for this?
\end{centering}

\parbox{5cm}{\ }
\parbox{1em}{\vskip8cm}

\normalsize
\vspace{5mm}
\begin{tabbing}
The Team:\= Antti Rasinen\\
         \> Mikko Korpela\\
         \> Janne Toivola\\
\vspace{5mm}

\end{tabbing}
%----------------------
Date: \today
%----------------------
\eject\newpage

\pagestyle{plain}

\tableofcontents

%\newpage
%
%\listoffigures


\newpage
\chapter{General description}
This document describes a software library developed by 
the authors at the laboratory of computer and information science at 
Helsinki University of Technology. The software library provides...
% What?


\section{Overview}
Some outline of the system... The parts and stuff...
% How?



\newpage
\chapter{Subsystem descriptions}
% The nasty details
\section{Variables}
\subsection{General}
All the variables $V$ are assumed to be discrete and have a certain
number of states: $c_V$ which is also known as the {\it cardinality} 
of the variable $V$. Thus the probability distribution i.e. likelihood 
$\lambda_V$ of a variable $V$ can be represented as a table of values 
and the size of the table is $c_V$. Furthermore, the sum of the values 
in the table equals one:
\begin{equation}
\sum_{v=0}^{c_V-1} \lambda_V[v] = 1.
\end{equation}
% some more? About relationships between variables perhaps? child-parent...

\subsection{The functionality description}

\subsubsection{The data structure}
The data type \cdatatype{Variable} defined in \cfilename{Variable.h} 
is a pointer to a struct which has the following fields: 
\begin{description}
\item[symbol] is a short string used for identifying the variable. Maximum
length is defined as \cdefine{VAR\_SYMBOL\_LENGTH} in
\cfilename{Variable.h}. To ensure the correct operation of the system, the 
symbol should be unique.

\item[name] is a little longer name to describe the variable: it is
called {\it label} in the Hugin net language files. This is NOT used for 
identification of the variables and it doesn't need to be unique. 
The maximum length is defined as \cdefine{VAR\_NAME\_LENGTH} in 
\cfilename{Variable.h}.

\item[statenames] is an array of strings containing names for all
possible states of the variable. The identification of data relies on
these strings. The size of the statenames array i.e. number of
strings should be the same as the number of states indicated by
cardinality field described below.

\item[cardinality] is a positive integer which tells how many states
the variable can have. It plays an important role in all calculations
so it better be correct: the value is not meant to be altered.

\item[id] is an \cdatatype{unsigned long} used for identification
inside the system. It is set automatically by the \cfunction{new\_variable} 
function and should not be tampered after that.

\item[likelihood] is a \cdatatype{double} array describing the probability
distribution of the states of the variable. It is used only for
entering evidence into the system and likelihood arrays of the latent
variables remain filled with ones. Size of the array equals
cardinality, of course.

\item[previous] is used for describing the repetitive structure in
timeslice models. It is a pointer to the variable which this variable
will replace in previous timeslice. The pointer is \cdatatype{NULL} if 
the model has no repetitive structure.

\item[next] is a same kind of pointer as \cstructfield{previous} above, 
but this one tells which variable will be replaced in the next timeslice.
The \cstructfield{previous} and \cstructfield{next} pointers should be 
symmetrical i.e. if \examplecode{a->next == b} then 
\examplecode{b->previous == a}.
\end{description}

\cfilename{Variable.h} provides also data types for implementing lists of
variables. Both \cdatatype{varlink} and \cdatatype{Variable\_iterator} are
pointers to structs which contain following fields:
\begin{description}
\item[data] is the variable (i.e. pointer to a variable struct) 
contained by the list element.

\item[fwd] is a pointer to the next element in the list or \cdatatype{NULL}
at the end of the list.

\item[bwd] is a pointer to the previous element in the list or 
\cdatatype{NULL} at the beginning of the list.
\end{description}
Variable iterators are meant to be used the same way as list iterators
in Java: you can get the next element contained by the list by just 
calling \examplecode{next\_Variable(iterator)}. On the other hand, iterators
are NOT meant to be the only reference to a list because it will
advance in the list, pointing always to the next element and eventually
be a null pointer.


\subsubsection{The functions}
The functions provided in \cfilename{Variable.c} are
%The interface + how the stuff works...
\begin{description}
\item[new\_variable(symbol, name, states, cardinality)] creates a
variable identified with the \cparameter{symbol} string. The 
\cparameter{name} string will be copied as the name field of the new 
variable. Both the \cparameter{symbol} and \cparameter{name} strings 
may be truncated to the allowed length. The states of the new variable 
will be named according to the given string array \cparameter{states}. 
All the given strings are copied, so remember to free them after they 
become useless.

\item[copy\_variable(v)] returns an exact copy of the
variable~\cparameter{v}. Note that also the id~field is copied and
consequently there may not be two copies of the same variable in the
same model.

\item[free\_variable(v)] frees the memory allocated for the
variable~\cparameter{v}. 

\item[equal\_variables(v1, v2)] returns 0 if either of the variables
are null. Otherwise it will tell if the variables have equal id fields
or not.

\item[get\_id(v)] will return the unsigned long id field of the 
variable~\cparameter{v}.

\item[get\_symbol(v)] returns the symbol of the
variable~\cparameter{v}. It will not make a copy of the string so
don't mess with it.

\item[get\_stateindex(v, state)] tells the place of the string
\cparameter{state} in the state name array of the
variable~\cparameter{v}. This index can be used for interpreting various
arrays describing probability distributions. 

\item[total\_num\_of\_vars()] is used only for aiding the Hugin net 
language file parser to return the total number of newly created 
variables. All the variables (created with the
\cfunction{new\_variable} function) are accumulated in a list and
this function can tell the size of that list.

\item[get\_first\_variable()] gives the first element in the list
of newly created variables mentioned above.

\item[get\_last\_variable()] gives the last element in the list
of newly created variables mentioned above.

\item[reset\_Variable\_list()] will replace the list of recently
created variables with \cdatatype{NULL} and set the size of the list
to zero. This is used only for resetting the list after copying the
list pointer to a new model. Otherwise all the models would share the
same list of parsed variables.

\item[next\_Variable(it)] will give the next variable pointed by the
variable iterator~\cparameter{it} and advance the pointer to the next
variable in the list. The function returns \cdatatype{NULL} if the
iterator runs out of variables.

\item[get\_parser\_variable(symbol)] aids the net language parser 
to find a variable, identified by the \cparameter{symbol} string, in the 
list of newly created variables.

\item[get\_variable(it, symbol)] searches the variable
iterator~\cparameter{it} for a variable identified by the string
\cparameter{symbol}. The iterator will be used by the function, so it
will not be pointing to the beginning of any lists anymore.

\item[update\_likelihood(v, likelihood)] will set the likelihood array
of variable~\cparameter{v} according to the given double array
\cparameter{likelihood}. Size of the given array should be the same
(or more) than the cardinality of the variable.

\item[reset\_likelihood(v)] fills the likelihood array of the
variable~\cparameter{v} with ones. This means that the likelihood of the
variable states will be uniform.

\item[number\_of\_values(v)] returns the cardinality of the
variable~\cparameter{v}. It is the exact number of states the variable
has and will always have.
\end{description}


\subsection{Other possibilities}
The Hugin net language parser is made with Bison and consequently the 
\cfunction{yyparse} function is not able to return a list of
variables etc. This makes it awkward to pass the results of parsing to
the rest of the program. Our solution is to create a list of parsed
variables in \cfilename{Variable.c} but it could also be at
\cfilename{parser.c} in order to avoid having weird functions like
\cfunction{get\_parser\_variable}.


\newpage
\section{Graphs}
\subsection{General}

In graphical models the graphical layout describes independence and
conditional independence between variables. This is exploited to
obtain a computationally efficient factorisation of the joint
probability distribution. 

The purpose of the graphical analysis is to find an optimal set of
clusters in the graphical model that has the join tree property. These
clusters are later merged into a join tree. This tree is then used for
the actual inference.

The main steps in the graphical analysis process are moralisation and
triangulation. Put simply, moralisation means that any nodes that have
a common child are connected. Furthermore, all directed links are
replaced with undirected links. The resulting graph is called a {\it
(undirected) moral graph}. 

This graph is then triangulated. The triangulation process also
extracts the cliques used to build the join tree.  There exist several
triangulations for a given graph; we are interested in a triangulation
that is optimal in the sense of adding the least edges\footnote{If
there is more than one optimal solution, further constrains may be
introduced. For example, for memory efficiency we prefer the solution
that generates the smallest potential tables.} to the moral
graph. Finding such a triangulation is an NP-hard problem, but there
exist heuristics that give nearly optimal results.  The triangulation
algorithm is the one presented in \cite{huang1994}.

The \cdatatype{Graph} is implemented via an adjacency graph. The
interface is designed to hide the implementation details. The
\cdatatype{Heap} datatype used in the triangulation stage contains a
\cdatatype{Graph}-like datatype and could possibly be refactored.


\subsection{The functionality description}
%The interface + how the stuff works...
\subsubsection{The data structures}
The data type \cdatatype{Graph} defined in \cfilename{Graph.h} is a
struct which has the following fields:
\begin{description}
\item[adj\_matrix] is an $n\times n$ adjacency matrix for the
graph. The size $n$ is specified when the graph is first constructed
and it is stored in the variable \cparameter{size}. The matrix is
implemented as a simple array. For this reason it is manipulated via
the macro \cparameter{ADJM}.
\item[variables] is an array of variables associated with this graph.
\item[size] is the number of variables in the \cdatatype{Graph}.
\item[var\_ind] is an internal array of variables. Used for
performance reasons.
\item[min\_id] The smallest \examplecode{id} of a variable associated
with the graph. Used internally for better performance.
\item[max\_id] The largest \examplecode{id} of a variable associated
with the graph. Used internally for better performance.
\item[top] is an internal counter used when adding variables. 
\end{description}


\subsubsection{The functions}

The functions provided in \cfilename{Graph.c} are:

\begin{description}
\item[new\_graph(n)] creates a new graph with memory reserved for $n$
variables. Returns a pointer.
\item[copy\_graph(G)] creates a copy of the graph \examplecode{G}.
\item[free\_graph(G)] frees the memory reserved for the graph
\examplecode{G}.
\item[get\_size(G)] returns the number of variables in the graph
\examplecode{G}.
\item[get\_variables(G)] returns the variables in the graph
\examplecode{G} as an array.
\item[get\_graph\_index(G, v)] returns the index of the variable
\examplecode{v} in the internal array of the graph \examplecode{G}.
\item[get\_neighbours(G, v\_array, v)] returns the number of
neighbours of variable \examplecode{v} in graph \examplecode{G}. The
neighbours will be stored in the array \examplecode{v\_array}, which
{\it must be large enough}. No variable can have more neighbours than
$n-1$, where $n$ is the number of variables in \examplecode{G}.
\item[is\_child(G, v1, v2)] will return \examplecode{True} when
variable \examplecode{v2} is a child of variable \examplecode{v1} in
the graph \examplecode{G}.
\item[add\_variable(G, v)] adds a new variable \examplecode{v} to the
graph \examplecode{G}. You must add as many variables as you specified
when creating \examplecode{G}.
\item[add\_child(G, v1, v2)] adds an edge to graph \examplecode{G}
from variable \examplecode{v1} to variable \examplecode{v2}, ie. makes
\examplecode{v2} a child of \examplecode{v1}.
\item[find\_cliques(G, cp)] finds cliques in \examplecode{G} and
stores them in the clique-array \examplecode{*cp}\footnote{Type of
\examplecode{cp} is \cdatatype{Clique**}, ie. it is a pointer to such
an array. It need not be initialized.}. Returns the number of elements
in the array.
\item[make\_undirected(G)] returns an undirected copy of Graph
\examplecode{G}.
\item[moralise(G)] returns a moralised copy of graph \examplecode{G}.

\end{description}

\subsection{Notes on Implementation}

The above discussion describes only the interface of the
\cdatatype{Graph} module. Some data structures used internally by the
\cdatatype{Graph} module are summarily described here. The explanation
is mostly aimed at those planning to modify the module.

\subsubsection{Heap}

The \cdatatype{Heap} is used to keep the potential cliques in a sorted
data structure. Any search structure would suffice here; the heap is
probably the most efficient.

This step requires a dynamically updatable \cdatatype{Heap}. The
weights in neighbouring nodes change when the minimum weight node is
removed. This also means that the heap implementation must be tied in
with the \cdatatype{Graph}. This has led to number of tradeoffs and
possible pitfalls.

 
XX


\subsubsection{cls2clq}

The \cdatatype{cls2clq} module is used to convert a list of clusters
to an array of cliques. In addition to a simple list implementation,
it also includes a method to check whether a given set of variables
(ie. a cluster) is a subset of a cluster already in the
list\footnote{There is no need to check for supersets; the items in
the list contain nodes that are then removed from the graph and thus
cannot occur in later clusters.} and a method for the list-to-array
conversion.

The list used in this implementation could be replaced with a generic
list data type.

\subsection{Other possibilities}

From efficiency standpoint, the approach presented in \cite{huang1994}
and suitable for production use.

If efficiency is not the main concern, eg. in prototyping situations,
some simplifications can be made. For example, the heap data structure
in the triangulation phase can be replaced with a list or array and a
linear search.

The interface is not as smooth and polished as it could be. It is also
not very flexible. For example you have to know the number of
variables when constructing the graph; the system should be able to
dynamically add new variables 'on the go'. However, such functionality
can be introduced with a wrapper, if desired.


\newpage
\section{Potentials}
\subsection{General}
As probability distributions of a single variable are implemented as 
tables, probability distributions relating to multiple discrete
variables can be represented as multidimensional tables. For example, 
if the variable~$X$ depends on a set of variables $\mathbf{Y}=$
$\{Y_1,\dots,Y_{N-1}\}$, the dependency can be described 
quantitatively by the probability distribution $P(X|\mathbf{Y})$. 
Another example could be a joint distribution $P(\mathbf{Z})$ of the 
variables $\mathbf{Z}=\{Z_1,\dots,Z_N\}$. These kind of distributions 
can be thought as functions from the N-dimensional space 
(formed by the variables $\{X\} \cup \mathbf{Y}$ or~$\mathbf{Z}$) 
to a real number $p \in [0,1]$. Since the variables have a discrete
and finite set of states, the function can be viewed as an
N-dimensional table $\phi_\mathbf{Z}$ containing the real numbers 
corresponding to the probabilities. As an example, 
the value $P(A=a_0, B=b_3, C=c_5)$ is found in a multidimensional
table $\phi_\mathbf{Z}$ as $\phi_{\mathbf{z}={0,3,5}}$ or 
\examplecode{P[0][3][5]}. 

There are two kinds of operations on potentials: marginalisation and
multiplication. Marginalisation is basically for reducing the number
of dimensions of a potential by calculating sums over the unnecessary 
variables. For example, if $\mathbf{X} \subseteq \mathbf{Z}$, 
$P(\mathbf{X})$ can be calculated from $P(\mathbf{Z})$ by summing over 
$\mathbf{Z} \setminus \mathbf{X}$ and similarly 
\begin{equation}
\phi_\mathbf{X} = \sum_{\mathbf{Z} \setminus \mathbf{X}} \phi_{\mathbf{Z}}.
\end{equation}
Which means that if we have $\mathbf{Z} = \{X, Z_2, Z_3\}$, then
\begin{equation}
\phi_X = \sum_{Z_2,Z_3} \phi_{\mathbf{Z}} \\
\Leftrightarrow \phi_X[i] = \sum_{j=0}^{c_{Z_2}-1}
\sum_{k=0}^{c_{Z_3}-1} \phi_\mathbf{Z}[i][j][k], \forall i \in [0,c_X-1]
\end{equation}

The multiplication operation has the same kind of idea: a potential can
be weighted with another one by multiplying suitable elements one by one.
Again, if we have $\mathbf{X} \subseteq \mathbf{Z}$, we may assign
\begin{equation}
\phi_\mathbf{Z} \leftarrow \phi_\mathbf{X} \phi_\mathbf{Z}.
\end{equation}
As an example, when $\mathbf{Z} = \{X, Z_2, Z_3\}$, the assignment
\begin{equation}
\phi_\mathbf{Z}[i][j][k] \leftarrow \phi_\mathbf{Z}[i][j][k]*\phi_X[i]
\end{equation}
is done for all combinations of 
$(i,j,k) \in [0,c_X-1]\times[0,c_{Z_2}-1]\times[0,c_{Z_3}-1]$.

From the implementation point of view, one of the most important
notions is that a multidimensional table can be referenced by a 
``flat index'' also. For example, if $\mathbf{X} = \{X_1,X_2\}$, then 
$\phi_\mathbf{X}[0] = \phi_\mathbf{X}[0][0]$, 
$\phi_\mathbf{X}[c_{X_1}-1] = \phi_\mathbf{X}[c_{X_1}-1][0]$,
$\phi_\mathbf{X}[c_{X_1}] = \phi_\mathbf{X}[0][1]$, and 
$\phi_\mathbf{X}[c_{X_1}*c_{X_2}-1] = \phi_\mathbf{X}[c_{X_1}-1][c_{X_2}-1]$. 
(Assuming that the first index of an array is the less significant one.)


\subsection{The functionality description}
%The interface + how the stuff works...
\subsubsection{The data structure}
The data type \cdatatype{potential} defined in \cfilename{potential.h} 
is a pointer to a struct which contains the following fields:
\begin{description}
\item[size\_of\_data] is an \cdatatype{integer} telling the total
number of elements in the potential. It must be the product of all the
elements in the \cstructfield{cardinality} array (or one if the number
of variables equals zero).
\item[cardinality] is an array of \cdatatype{integers}. The integers
are the cardinalities of each variable the potential is related
to. Thus the size of the array must be the same as the number of
variables. Also the order of the cardinality array is significant
because the variables are assumed to have a certain order.
\item[num\_of\_vars] is an \cdatatype{integer} which tells the number
of variables associated with the potential.
\item[data] is the \cdatatype{double array} describing a probability
distribution of the associated variables. The size of this array is in
the \cstructfield{size\_of\_data} field. The data in the array is
arranged according to the order of the corresponding variables: the
variable which has its cardinality first in the
\cstructfield{cardinality} array is considered least significant in
the sense of placing a value in the \cstructfield{data} array.
\end{description}


\subsubsection{The functions}
The functions provided for manipulating \cdatatype{potentials} are 
placed in \cfilename{potential.c} and are as follows:
\begin{description}
\item[make\_potential(cardinality, num\_of\_vars, data)] creates a
potential struct according to the parameters and returns a pointer
to it. The resulting potential will have its cardinalities of
variables set according to the given \cparameter{cardinality} array by
copying the elements in it. The number of associated variables is
given as the integer \cparameter{num\_of\_vars}. 

The \cparameter{data} parameter can be a null pointer or a 
\cdatatype{double array} of the size equal to the product of the 
cardinalities of the variables. In case of a null pointer, the
potential will be initialised to uniform distribution. Otherwise the 
contents of the \cstructfield{data} array in the potential struct will
be copied from the given \cparameter{data} array.

\item[free\_potential(p)] frees the memory allocated for the
potential~\cparameter{p}. 

\item[copy\_potential(source, destination)] copies the distribution
contained in the \cparameter{source} potential to the given
\cparameter{destination} potential. Note that both of the potentials must
be already existent and otherwise equal. Use the 
\cfunction{make\_potential} function if you need an entire new copy of 
a potential.

\item[get\_pvalue(p, indices)] retrieves the possibly non-normalised
probability of the configuration of variables, described by the 
\cdatatype{integer array} \cparameter{indices}, from the 
\cdatatype{potential}~\cparameter{p}. The \cparameter{indices} array 
tells which value each of the associated variables are assigned: 
$n-1$ in the array corresponds to the $n$:th value of the variable. 
The \cparameter{indices} must be in the same order as the corresponding 
variables and their cardinalities in the potential~\cparameter{p}. 

\item[set\_pvalue(p, indices, value)] sets a \cdatatype{double}
\cparameter{value} in the \cdatatype{potential}~\cparameter{p} the same 
way as \cfunction{get\_pvalue(p, indices)} retrieves it. 
(See the description above.)

\item[inverse\_mapping(p, flat\_index, indices)] transforms a
so-called flat index into the \cdatatype{integer array} 
\cparameter{indices} according to the \cdatatype{potential}~\cdatatype{p}. 
A flat index is an index used for addressing data in the potential and 
is therefore an integer between \examplecode{0} and
\examplecode{p->size\_of\_data - 1} inclusive. Shortly, this function is 
made for finding out which configuration of states of the variables 
corresponds to each element in the potential. Note that the 
\cparameter{indices} array is not allocated by the function.

\item[general\_marginalise(source, destination, source\_vars)] is one
of the most useful functions since it computes the marginalisation
i.e. a sum over the variables indicated by the given 
\cdatatype{integer array} \cparameter{source\_vars} and places the 
result in the given \cparameter{destination} potential. To make any 
sense, the number of associated variables in \cparameter{source} must 
be greater than in \cparameter{destination}. The implementation
assumes that the variables common to the potentials are in the same 
order. Consequently, all the variables in a system must have a total 
and static ordering in order to keep all the sets of variables shared 
by neigbouring clique potentials in order.

The \cdatatype{integer array} \cparameter{source\_vars} indicates which
variables are marginalised away. It consists of indices ranging from
\examplecode{0} to \examplecode{source->num\_of\_vars - 1} inclusive. 
The array must be arranged in ascending order and the size must equal 
the difference in the numbers of associated variables in the potentials. 
Simply, a zero in the array tells the function to marginalise over the 
first variable. Note that the result is not normalised.

\item[total\_marginalise(source, destination, variable)] can be used
for finding out the probability distribution of a single variable
according to the \cparameter{source} potential. The function is
similar to the \cfunction{general\_marginalise} but instead of telling 
which variables to marginalise away, the user must indicate which
variable is left unmarginalised. The parameter \cparameter{variable} is 
an \cdatatype{integer} ranging from \examplecode{0} to
\examplecode{source->num\_of\_vars - 1} inclusive. Zero indicates the 
first variable in the potential.

Another difference arises from the fact that the probability 
distribution of a single variable fits into a one-dimensional array. 
The place to put the resulting \cdatatype{double array} 
(\cparameter{destination}) is given to the function as one of the
parameters. Size of the array must be equal (or greater) to the
cardinality of the desired variable, so remember to allocate one
before calling this function. Note that the result is not normalised.

\item[update\_potential(numerator, denominator, target, extra\_vars)] 
implements the multiplication of potentials. The function simply
multiplies the elements of the \cparameter{target} potential with the
corresponding elements in the \cparameter{numerator} potential. At the
same time, the function is able to divide the \cparameter{target}
potential with the optional \cparameter{denominator} potential. If no
division is needed, \cparameter{denominator} can be \cdatatype{NULL}.
The \cparameter{numerator} and \cparameter{denominator} potentials are 
left unchanged by the function.

The function is made for multiplying the a clique potential with the 
old and new sepset potentials. It is assumed that the variables
associated with the multiplier potentials are a subset of the
variables associated with the target potential. Thus the user needs to
indicate which of the variables in the target potential are not
associates with the multiplier potentials. This is achieved with the
fourth parameter \cparameter{extra\_vars} which is an 
\cdatatype{integer array}. The array must be in ascending order. For 
example, a zero in the array indicates that the first variable of the 
target potential is not amongst those associated with the multiplicand 
potentials.

\item[update\_evidence(numerator, denominator, target, var)] is made
for multiplying potentials with probability distributions of a single
variable. The potential to be manipulated is given as the
\cparameter{target} parameter. It is multiplied by the given 
\cdatatype{double array} \cparameter{numerator} which usually
represents the probability distribution of a variable. The 
\cparameter{denominator} is a similar \cdatatype{double array} used 
for dividing the \cparameter{target} potential. If not needed, the 
\cparameter{denominator} can be \cdatatype{NULL}.

Typically the function is used for multiplying evidence into a clique 
potential and dividing with possible old evidence. The variable, whose 
distribution is to be passed into the potential, must be indicated 
with the \cparameter{var} \cdatatype{integer}. E.g. a zero tells the 
function that the evidence is about the first variable associated with 
the potential.

\item[init\_potential(probs, target, extra\_vars)] is essentially the
same as the \cfunction{update\_potential} function. It is meant for
multiplying the \cparameter{target} potential with the given
\cparameter{probs} potential. If the potentials are similar, i.e. they
have the same associated variables, the \cparameter{extra\_vars} parameter 
should be \cdatatype{NULL}. Otherwise, \cparameter{extra\_vars} is an 
\cdatatype{integer array} indicating which of the variables associated 
with the target potential are not associated with the multiplier potential.

\item[print\_potential(p)] is mainly for debugging purposes. It prints 
the contents of the \cdatatype{potential}~\cparameter{p} to the 
standard output.
\end{description}


\subsection{Other possibilities}
There are several ways of implementing the calculations of the potentials
without keeping the corresponding variables in a certain order. This
could be achieved by using an integer array to remap the order of the
variables instead of telling which are not included and assuming that
the rest of the variables are in the same order in both potentials.


\newpage
\section{Join trees} % Cliques and sepsets
\subsection{General}

The idea and mathematical formulas...


\subsection{The functionality description}
The files \cfilename{Clique.h} and \cfilename{Clique.c} provide data 
types and functions for operating with sepsets and cliques. Together 
these form the concept known as join tree. In the NIP system, a join 
tree is merely an array of cliques which in turn have references to
all the necessary sepsets.

\subsubsection{The data structures}
\cfilename{Clique.h} provides data types \cdatatype{Sepset}, 
\cdatatype{Sepset\_link}, and \cdatatype{Clique}. \cdatatype{Sepset}
is a pointer to a struct which has the following fields:
\begin{description}
\item[old] is older of the two last \cdatatype{potentials} passed via
the sepset.

\item[new] is the last \cdatatype{potential} passed via the sepset.

\item[variables] is an \cdatatype{array of Variables}. These are the 
variables associated with the sepset. They are in the same order as
their cardinalities in the \cdatatype{potentials} \cstructfield{old} and 
\cstructfield{new}. The number of the variables can be found in either 
of the \cdatatype{potentials} \cstructfield{old} and \cstructfield{new}.

\item[cliques] is an \cdatatype{array of Cliques}. The references to the
adjacent cliques are there. The size of the array is always two
because of the nature of sepsets.
\end{description}


The data type \cdatatype{Sepset\_link} provides an implementation for lists
of \cdatatype{Sepsets}. It is a pointer to a struct containing
\begin{description}
\item[data] is a so-called \cdatatype{void pointer} because of the order of
definitions. (You can't really define a list of sepsets before you
have defined sepsets. Sepsets can't be defined before cliques and
cliques can't be defined before lists of sepsets.) When the list of
sepsets is used, the \cstructfield{data} field has to be cast to the 
\cdatatype{Sepset} type. 

\item[fwd] is the next \cdatatype{Sepset\_link} in the list or 
\cdatatype{NULL} at the end of the list.

\item[bwd] is the previous \cdatatype{Sepset\_link} in the list or 
\cdatatype{NULL} at the beginning of the list.

\end{description}

The data type \cdatatype{Clique} is a pointer to a struct containing all the
necessary for working with cliques. The fields are
\begin{description}
\item[p] is the clique \cdatatype{potential}

\item[original\_p] is the original clique \cdatatype{potential} initialised
according to the parameters of the model

\item[variables] is an \cdatatype{array of Variables}. These are the
references to the variables associated with the clique. They are in
the same order as their cardinalities in the 
\cdatatype{potential}~\cstructfield{p}. The number of variables can be 
found in the potential~\cstructfield{p}.

\item[sepsets] is a \cdatatype{Sepset\_link} i.e. either
\cdatatype{NULL} or a list of sepsets. The list contains the
references to the adjacent sepsets.

\item[num\_of\_sepsets] is the number of adjacent sepsets.

\item[mark] is an \cdatatype{integer} used as a flag by various
algorithms. For example a depth-first search and the propagation of 
evidence uses the \cstructfield{mark} field to identify the cliques 
which have already been handled.
\end{description}


\subsubsection{The functions}
The file \cfilename{Clique.c} provides the following functions
\begin{description}
\item[make\_Clique(vars, num\_of\_vars)] creates a \cdatatype{Clique}. The
associated variables are given as the \cdatatype{Variable array}
\cparameter{vars} and the number of the variables as the \cdatatype{integer} 
\cparameter{num\_of\_vars}. A shallow copy of the array is made, so
remember to free it (but not the contents). The clique will not have 
any adjacent sepsets initially. Sepsets must be added separately.

\item[free\_Clique(c)] frees the memory allocated by a the 
\cdatatype{Clique}~\cparameter{c}. It will not free the memory allocated for 
the corresponding \cdatatype{Variables}, but all the adjacent 
\cdatatype{Sepsets} are freed and removed automatically so that rest
of the join tree remains valid. Note that freeing an entire join tree
can be done by calling this function for every clique.

\item[add\_Sepset(c, s)] adds the \cdatatype{Sepset} \cparameter{s} to the 
\cdatatype{Clique}~\cparameter{c}. Remember to add the sepset to both
adjacent cliques and never add a sepset to the same clique twice.

\item[make\_Sepset(variables, num\_of\_vars, cliques)] creates a {\it
Sepset}. The associated variables are given as the \cdatatype{Variable
array} \cparameter{variables} and the size of the array as the {\it
integer} \cparameter{num\_of\_vars}. Both adjacent cliques must be given
as an \cdatatype{array of Cliques} (\cparameter{cliques}). This
usually means that the \cdatatype{Cliques} must be created before the
\cdatatype{Sepsets}. Note that a shallow copy of the parameter arrays
is made, so freeing the arrays after calling the function is up to the user.

\item[free\_Sepset(s)] just frees the memory allocated for the
\cdatatype{Sepset} \cparameter{s}. This is called automatically by 
\cfunction{free\_Clique} so usually this function is needed only for
freeing possible useless \cdatatype{Sepsets} which are not included in the 
join tree.

\item[create\_Potential(variables, num\_of\_vars, data)] can help if
you need to create potentials out of \cdatatype{double arrays} like 
the \cparameter{data} parameter. The function creates a \cdatatype{potential} 
which has its data arranged correcty in order to work with the
system. To rearrange the data correctly, the function needs to know 
the order of the corresponding variables. This is achieved by 
specifying the \cdatatype{Variable array} \cparameter{variables} and the size 
of it as the \cdatatype{integer} \cparameter{num\_of\_vars}. 

The most important thing is to have the \cdatatype{Variables} array in the 
same order as the \cparameter{data} array is sorted. For example, the 
potentials specified in the Hugin net language have the child variable
as the least significant one: the value of the variable has the least 
effect on the placement of the data. Thus the child variable should be 
the first in the array. Note that for some reason the first parent 
variable specified in the Hugin net language should be the last in 
the \cparameter{variables} array, and the last parent should be the 
second right after the child variable.

\item[unmark\_Clique(c)] resets the mark in the 
\cdatatype{Clique}~\cparameter{c}. Note that this has to be done for 
every clique before calling \cfunction{distribute\_evidence} or 
\cfunction{collect\_evidence}.

\item[clique\_num\_of\_vars(c)] tells how many associated variables the 
\cdatatype{Clique}~\cparameter{c} has.

\item[sepset\_num\_of\_vars(s)] tells how many associated variables the 
\cdatatype{Sepset}~\cparameter{s} has.

\item[distribute\_evidence(c)] implements the algorithm which spreads 
the evidence entered in to the cliques away from the given 
\cdatatype{Clique}~\cparameter{c}. See \cite{huang1994} page 21 for
details. 

\item[collect\_evidence(c1, s12, c2)] implements the algorithm which 
collects evidence from the subtree rooted in the given 
\cdatatype{Clique}~\cparameter{c2} and passes the evidence to the 
\cdatatype{Clique}~\cparameter{c1}. The
\cdatatype{Sepset}~\cparameter{s12} is the sepset between the two 
cliques. The function is recursive and is usually used like this: 
\examplecode{collect\_evidence(NULL, NULL, c);} 
where \examplecode{c} is some \cdatatype{Clique}. This causes the 
evidence to be collected from the entire join tree.

\item[initialise(c, child, parents, p)] is used for entering the
quantitative parameters of the model into the join tree. This function
initialises the \cdatatype{Clique}~\cparameter{c} with the given 
\cdatatype{potential}~\cparameter{p}. The initialisation ensures that 
the parameters are not reset by the \cfunction{global\_retraction} 
function. Note that~\cparameter{p} should be a valid 
\cdatatype{potential} i.e. the data contained by it should be 
correctly arranged and the number of variables specified in it should 
equal to the number of parent variables plus one (the child).

Since the clique to be initialised can be associated with more
variables than are associated with the potential, the user must
specify the \cparameter{child} \cdatatype{Variable} and the 
\cdatatype{array of variables} which contain the
\cparameter{parents}. The order of the variables in the
\cparameter{parents} array is not relevant and the array is not needed 
after the function has executed.

\item[marginalise(c, v, r)] is one of the most useful functions
because it finds out the probability distribution of the 
\cdatatype{Variable}~\cparameter{v} according to the 
\cdatatype{Clique}~\cparameter{c} and writes it into the 
\cdatatype{double array}~\cparameter{r} (as in \textbf{r}esult). 
The array must be allocated before the function is called and the size 
must be at least \examplecode{v->cardinality}. Note that the result is 
NOT normalised.

\item[normalise(result, array\_size)] simply normalises the
\cdatatype{double array} \cparameter{result}. After the function has
executed, sum of the elements in the array will be one, unless it's 
filled with zeros. If the array is full of zeros, it is left
unchanged. The size of the array must be specified as the 
\cdatatype{integer} \cparameter{array\_size}.

\item[global\_retraction(vars, cliques, num\_of\_cliques)] resets the 
clique potentials to the state they had after the initialisation and 
enters the most recent evidence into the cliques. Thus the join tree
consisting of the cliques is left at an inconsistent state and you may
want to execute the global propagation consisting of 
\cfunction{collect\_evidence} and \cfunction{distribute\_evidence}. 

This function is needed for retracting evidence in some cases. To
achieve this, the user must enter the wanted evidence into the
variables and run \cfunction{global\_retraction}. The 
\cdatatype{Variable\_iterator} \cparameter{vars} (list of all the 
variables) and a \cdatatype{Clique array} \cparameter{cliques} must be 
specified. Also the number of the cliques has to be given to the 
function as the \cdatatype{integer} \cparameter{num\_of\_cliques}.

\item[enter\_observation(vars, cliques, num\_of\_cliques, v, state)] 
is made for incorporating hard evidence into a join tree. The observed
state of the \cdatatype{Variable}~\cparameter{v} is given as a 
\cdatatype{string} named \cparameter{state}. The function needs also 
the \cdatatype{Variable\_iterator} \cparameter{vars}, 
\cdatatype{Clique array} \cparameter{cliques} and the size of it
as the \cdatatype{integer} \cparameter{num\_of\_cliques}. The reference
\cparameter{vars} to the list of all variables is needed because of the
possible global retraction. The function \cfunction{global\_retraction}
is called automatically if needed.

\item[enter\_i\_observation(vars, cliques, num\_of\_cliques, v, index)]
is made for entering an observation as an \cdatatype{integer} into a join
tree. This is equal to the function \cfunction{enter\_observation} but
instead of telling the observation as a string, the user should encode
the observation as the \cdatatype{integer} \cparameter{index}. A zero
corresponds to the first state of the variable defined in the Hugin
net language file. (See the \cfunction{get\_stateindex} function also.)

\item[enter\_evidence(vars, cliques, num\_of\_cliques, v, evidence)]
is made for entering soft evidence into a join tree. (Note that hard
evidence is only a special case of soft evidence.) The function is
similar to the \cfunction{enter\_observation} and
\cfunction{enter\_i\_observation} functions above but instead of
describing a single state, the user must specify a probability
distribution as the \cdatatype{double array} \cparameter{evidence}. 
The array is assumed to be normalised.

\item[find\_family(cliques, num\_of\_cliques, variables, num\_of\_vars)]
tries to find a \cdatatype{Clique} which contains all the variables (or
more) specified in the \cdatatype{Variable array}
\cparameter{variables}. The number of variables has to be given as the 
fourth parameter \cparameter{num\_of\_vars}. The function returns 
\cdatatype{NULL} if there are no suitable cliques in the specified 
\cdatatype{array of Cliques} (\cparameter{cliques}) within the given 
size \cparameter{num\_of\_cliques}.

\item[find\_sepsets(cliques, num\_of\_cliques)] creates and inserts 
the sepsets between the \cdatatype{Cliques} specified in the array 
\cparameter{cliques}. The size of the array must be given as the 
\cdatatype{integer} \cparameter{num\_of\_cliques}. This function is 
meant to be used only once after all of the cliques have been created. 
Consequently, it is not intended for repairing partially created 
join trees.

\item[print\_Clique(c)] is meant for debugging purposes. It prints the
symbols of the variables associated with the
\cdatatype{Clique}~\cparameter{c} to the standard output.

\item[print\_Sepset(s)] is meant for debugging purposes. It prints the
symbols of the variables associated with the
\cdatatype{Sepset}~\cparameter{s} to the standard output.

\item[clique\_intersection(cl1, cl2, vars, n)] finds out which
variables are common to the specified \cdatatype{Cliques}~\cparameter{cl1}
and~\cparameter{cl2}. The parameter \cparameter{vars} is a 
\cdatatype{pointer to an array of Variables} and the array will 
contain the found variables  after the execution. The size of the
array is written to the place pointed by the 
\cdatatype{integer pointer}~\cparameter{n}. The resulting array
is allocated by the function and it should be freed by the user.
\end{description}


\newpage
\section{The Hugin net language parser}
\subsection{General}

% The structure of net files


\subsection{The functionality description}
The parser, for reading models from Hugin net language files, is
written in two files: \cfilename{huginnet.y} contains the lexer and 
description of the language for the Bison parser generator and 
\cfilename{parser.c} contains lots of helper functions for the parser. 
The data structures used for parsing are defined in the
\cfilename{parser.h} file. There's also a file named
\cfilename{fileio.c} which contains functions for tokenising the 
lines read from files.

\subsubsection{The data structures}
The \cfilename{parser.h} file defines several data types used with the
parser implementation. One of them is \cdatatype{doublelink} which is a
pointer to a struct which can hold a \cdatatype{double} and consequently
form a list of floating point numbers. The struct contains the
following fields
\begin{description}
\item[data] is the \cdatatype{double} number contained by the list element.

\item[fwd] is a \cdatatype{doublelink} i.e. a pointer to the next element in
the list or \cdatatype{NULL} at the end of the list.

\item[bwd] is a \cdatatype{doublelink} i.e. a pointer to the previous
element in the list or \cdatatype{NULL} at the beginning of the list.
\end{description}

Another kind of useful data type is \cdatatype{stringlink} which is a
pointer to a struct. The struct can be used as an element in a list of
strings. The element contains the following fields
\begin{description}
\item[data] is the \cdatatype{string} i.e. an array of characters.

\item[fwd] is a \cdatatype{stringlink} i.e. a pointer to the next element in
the list or \cdatatype{NULL} at the end of the list.

\item[bwd] is a \cdatatype{stringlink} i.e. a pointer to the previous
element in the list or \cdatatype{NULL} at the beginning of the list.
\end{description}

Since the conditional probability distributions and the structure of
the model are both encoded into the \examplecode{potential}
declarations of the net language, the distributions have to be 
temporarily stored until the entire net file has been parsed and the 
join tree is made. In other words, you can't enter the quantitative 
parameters of the model until you know the qualitative structure of
it. This is why the parser stores all the \cdatatype{potentials} read 
from the net file into a list until the end of parsing. This is where 
the data type \cdatatype{initDataLink} comes handy. It is a pointer to
a struct which holds the following fields
\begin{description}
\item[data] is the \cdatatype{potential} stored by the list element.

\item[child] is the \cdatatype{Variable} which was defined to depend on
other variables in the potential declaration of the net language.

\item[parents] is an \cdatatype{array of Variables} which contains the
parent variables of the \cstructfield{child}. Instead of an array it 
may be \cdatatype{NULL} if the \cstructfield{child} was an independent
variable and had no parents.

\item[fwd] is a pointer to the next element in the list or 
\cdatatype{NULL} at the end of the list.

\item[bwd] is a pointer to the previous element in the list or 
\cdatatype{NULL} at the beginning of the list.
\end{description}

A same kind of problem arises with the \examplecode{node} declarations 
of the Hugin net language when timeslices are defined. The parser 
can't assign the pointer from a \cdatatype{Variable} to the 
corresponding \cdatatype{Variable} in the next timeslice before both
of the variables have been parsed. This is solved by collecting the 
information about timeslice dependencies into a list until all the 
variables have been read from the net file. The file
\cfilename{parser.h} defines a data type for this purpose: 
\cdatatype{time\_init\_link} is a pointer to a struct which can be
used as an element in a linked list and holds the following fields
\begin{description}
\item[var] is the \cdatatype{Variable} which corresponds
to another one in the next timeslice.

\item[next] is the symbol \cdatatype{string} which identifies the
corresponding variable in the next timeslice.

\item[fwd] is a \cdatatype{time\_init\_link} i.e. a pointer to the next
element in the list or \cdatatype{NULL} at the end of the list.
\end{description}

There's also a small parser for the data files. A data type has been
defined for reading timeseries data from files. The data type 
\cdatatype{datafile} is a struct which contains the following fields
\begin{description}
\item[name] is a string (\cdatatype{char array}) which contains the 
name of the file.

\item[separator] is the character (a single \cdatatype{char}) which is used 
as the separator between elements on a row in the data file.

\item[file] is a file handle of the type \cdatatype{FILE}.

\item[is\_open] is an \cdatatype{integer} telling whether the file is open
or not.

\item[firstline\_labels] is an \cdatatype{integer} which indicates whether
the first line of the data file contains node labels of the
corresponding variables or not. 

\item[line\_now] is an \cdatatype{integer} which tells the current position
in the file.

\item[datarows] is an \cdatatype{integer} telling the number of data rows in
the file i.e. the length of a timeseries. If there's a line containing
the node labels in the beginning of the file, it is not counted as a
data row.

\item[node\_symbols] is an \cdatatype{array of strings}. It contains the
symbols (short names) of the observed variables. These are usually
found on the first line of the data file.

\item[num\_of\_nodes] tells the number of the observed variables as an
\cdatatype{integer}.

\item[node\_states] is a \cdatatype{two-dimensional array of
strings}. It contains the names of the states of every observed
variable. For example \examplecode{node\_states[i][j]} is a name of a
state of the $i:th$ observed variable, assuming that $j \in [0, c-1]$, 
where $c$ is the cardinality of the variable. This array is
particularly useful if the model is created automatically from data
and not read from a net file.

\item[num\_of\_states] is an \cdatatype{array of integers} which tells how
many different states corresponding observed variable has had in the
data file.
\end{description}


\subsubsection{The functions}
The file created by Bison, \cfilename{huginnet.tab.c}, contains the
function which starts the Hugin net language file parser for reading a model
from a file.
\begin{description}
\item[yyparse()] must be included as an {\it external} function. 
(like \examplecode{extern int yyparse();}) It is the function which 
causes a model being parsed from a file. Use the helper functions at 
\cfilename{parser.c} to open the net language file prior to parsing, 
to close it after the execution and to dig out the newly created model.
\end{description}

For the sake of completeness, the lexer is described too. The file 
\cfilename{huginnet.y} contains the following function
\begin{description}
\item[yylex()] is used only by the parser created with Bison parser
generator. The function reads tokens from the input file, recognises
them and passes them to the parser appropriately.
\end{description}
It uses extensively the helper functions found in
\cfilename{fileio.c}. These are as follows
% fileio.c
\begin{description}
\item[count\_words(s, chars)] returns the number of words in the 
\cdatatype{string}~\cparameter{s}. The words are separated by white 
space and \cparameter{s} must be null terminated. If the 
\cdatatype{integer pointer} \cparameter{chars} is not a null pointer, 
the number of characters in~\cparameter{s} is written there.

\item[count\_tokens(s, chars, q\_strings, separators,
n\_separators, sep\_tokens, wspace\_sep)] counts the number of
tokens in the null terminated \cdatatype{string}~\cparameter{s}. The 
result is returned as an \cdatatype{integer}. The number of characters 
in the string is written to the integer referenced by the 
\cdatatype{integer pointer} \cparameter{chars}. 

Rest of the parameters make the function extremely versatile. The 
\cdatatype{integer} \cparameter{q\_strings} indicates whether possible
substrings enclosed in double quotes ('') should be considered as
single tokens or not. The \cdatatype{character array} 
\cparameter{separators} may be used for specifying additional
separators. Each character in the array behaves as a separator. 
A white space is always a separator. The number of the additional 
separators must be specified as the \cdatatype{integer} 
\cparameter{n\_separators}.

The \cdatatype{integer} \cparameter{sep\_tokens} is used as a flag 
to indicate whether the separators themselves should be considered as 
tokens or not. Finally, the \cdatatype{integer}
\cparameter{wspace\_sep} indicates whether white space should be 
considered as a separator token or just a plain separator.

\item[tokenise(s, n, q\_strings, separators, n\_separators, 
sep\_tokens, wspace\_sep)] is the tool for finding \cparameter{n} first 
tokens in the null terminated \cdatatype{string}~\cparameter{s}. The 
function returns an \cdatatype{array of integers} which tells where 
each token begins and where they end. The first integer in the array 
tells which character in the string begins the first token. The second
integer tells the place of the first character NOT included in the
first token. The third and fourth integers tell the placement of the
second token and so on.

Rest of the parameters are similar to the ones in the 
\cfunction{count\_tokens} function. The \cdatatype{integer} 
\cparameter{q\_strings} indicates whether we want quoted strings to 
be single tokens or not. The \cdatatype{character array} 
\cparameter{separators} specify separators in addition to white space 
and the \cdatatype{integer} \cparameter{n\_separators} tells the 
number of additional separators. The \cdatatype{integer} 
\cparameter{sep\_tokens} indicates whether we want the
separators to be tokens as well. If the \cdatatype{integer}
\cparameter{wspace\_sep} is not zero, the white space will behave as
separator but will not be considered as a token even if the other
possible separators are.

\item[split(s, indices, n)] uses the \cdatatype{integer array}
\cparameter{indices} (made by the \cfunction{tokenise} function) to
split the null terminated \cdatatype{string}~\cparameter{s} into 
\cparameter{n} strings. The function returns the strings as an array. 
(\cdatatype{char**} i.e. an array of character arrays)
\end{description}


Most of the actions executed by the net language file parser is done by the
functions in \cfilename{parser.c}. The functions are as follows
\begin{description}
\item[open\_yyparse\_infile(filename)] is one of the most important
functions in reading models from files. It opens a file for the parser
for reading and returns zero if the file was opened successfully. The 
name of the file is given as the \cdatatype{string} \cparameter{filename}.

\item[close\_yyparse\_infile()] should be called after parsing a model
from a file. It closes the net language file appropriately.

\item[open\_datafile(filename, separator, write, nodenames)] is used
for opening data files for reading or writing. The function returns a 
pointer to the created \cdatatype{datafile} struct. The name of the data
file is given as the \cdatatype{string} \cparameter{filename} and the used
separator is given as the \cdatatype{character}
\cparameter{separator}. The \cdatatype{integer} \cparameter{write} is used
for indicating whether the file should be opened for reading only
(zero) or for writing only (non-zero). The \cdatatype{integer} flag
\cparameter{nodenames} tells the function to treat the first line of
the file as regular data (zero) or use the tokens on the line as the 
symbols of the variables. If \examplecode{nodenames == 0} the function 
invents its own symbols for the variables to be included with the 
\cdatatype{datafile} struct.

\item[close\_datafile(file)] closes the data file included in the
given \cdatatype{datafile pointer} \cparameter{file} and frees the memory
allocated for the \cdatatype{datafile} struct.

\item[nextline\_tokens(f, separator, tokens)] is the function made for
reading data files. It reads the next line of the \cdatatype{datafile}
referenced by the pointer~\cparameter{f} and splits the line into
tokens. The separator should be specified as the \cdatatype{character}
\cparameter{separator}. The function returns the number of tokens as an 
\cdatatype{integer} and sets the pointer \cparameter{tokens} to
reference the resulting \cdatatype{array of strings}. I.e. 
\cparameter{tokens} is a pointer to an array of character arrays, or
in other words a \examplecode{char***}. Make sure that you don't lose 
any existing pointers by calling this function, because freeing the 
tokens read from the file is up to the user.

\item[next\_token(token\_length)] is used by the net language
parser. The function returns the next token from the opened net file
and writes the length of the token to the \cdatatype{integer} referenced by
the pointer \cparameter{token\_length}. The token is a (null terminated)
\cdatatype{string} i.e. an array of characters. The token length does not
include the NULL character and equals zero if there are no more tokens
in the file. After the token string has been used, please free the
memory allocated for it.

\item[add\_symbol(v)] is used only by the net language parser. The
function adds the \cdatatype{Variable}~\cparameter{v} into a temporary 
list of parent variables. The list is needed for parsing the parent 
variables according to the potential declarations of the net
language. (See also the \cfunction{make\_variable\_array} function)

\item[add\_initData(p, child, parents)] is used only by the net
language parser. This function adds the parsed 
\cdatatype{potential}~\cparameter{p}, the \cdatatype{Variable} 
\cparameter{child} and its \cparameter{parents} in an 
\cdatatype{array of Variables} to the list of parsed potentials. 
The potentials are collected into the list until the join tree has
been created and it can be initialised with the potentials.

\item[add\_time\_init(var, next)] is used only by the net language
parser. It adds information about the correspondence of nodes between
timeslices into a temporary list. The \cdatatype{Variable}
\cparameter{var} will correspond to the \cdatatype{Variable}
identified by the symbol \cdatatype{string} \cparameter{next} in the 
next timeslice. The information has to be collected into a list,
because the another variable may haven't been created yet at the
moment. After the variables have been parsed, the list is cleaned.

\item[add\_double(d)] is used only by the net language parser. The
function adds the \cdatatype{double}~\cparameter{d} into a temporary list of
floating point numbers. Usually the list is used for storing the
numbers of the data fields of the potential declarations in the net
files. The list can be turned into an array by the
\cfunction{make\_double\_array} function.

\item[add\_string(string)] is used only by the net language
parser. Calling this function will add the null terminated \cdatatype{array
of characters} \cparameter{string} into a temporary list. The list is used
for storing the names of the states declared in the node declarations
of the net language. The list can be turned into an array by using the
\cfunction{make\_string\_array} function.

\item[make\_variable\_array()] is used only by the net language
parser. The function creates an array containing the \cdatatype{Variables}
accumulated in the temporary list by \cfunction{add\_symbol}
function. The resulting array is usually used as the array of parent 
variables.

\item[make\_double\_array()] is used only by the net language
parser. It creates an \cdatatype{array of doubles} containing the numbers
accumulated into the temporary list by the the \cfunction{add\_double}
function. The array is used as the data for the parsed potentials. 

\item[make\_string\_array()] is used only by the net language
parser. The function creates an \cdatatype{array of strings} out of the list
created by the \cfunction{add\_string} function. The array is used as the
statename array of the parsed variables.

\item[reset\_doubles()] cleans the temporary list of floating point
numbers created with the \cfunction{add\_double} function. The function
should be used only by the net language parser.

\item[reset\_strings()] cleans the list of \cdatatype{strings} gathered with
the \cfunction{add\_string} function. This function does NOT free the
actual strings, only the list structure. The function is meant to be
used only by the net language parser.

\item[reset\_symbols()] cleans the temporary list of variables made by
the \cfunction{add\_symbol} function. The function does NOT free the
actual \cdatatype{Variables}, only the list structure itself. It is meant to
be used only by the net language parser.

\item[reset\_initData()] cleans the data used for initialising the
join tree. The function also frees the \cdatatype{potentials} and the arrays of
parent \cdatatype{Variables} gathered in the list. (The variables themselves
are not freed, of course.) The function is meant to be used only by
the net language parser.

\item[reset\_timeinit()] cleans the temporary list about the timeslice
correspondencies accumulated by the \cfunction{add\_time\_init} function.
Only the list structure and the stored symbol string are freed, not
the referenced variables. The function is meant to be used only by the
net language parser.

\item[init\_new\_Graph()] is meant to be used only by the net language
parser. The function initialises a new \cdatatype{Graph} which can hold as
many variables than is parsed from the file so far.

\item[parsedVars2Graph()] executes one stage in the net language
parser. It inserts the \cdatatype{Variables} into the initialised
\cdatatype{Graph} after all of the variables have been created. The
function adds also the child-parent relation to the
\cdatatype{Graph}. Therefore it must be called after all of the
\verb+potential+ declarations of the net file have been parsed and the
information can be found from the initialisation list accumulated by
the \cfunction{add\_initData} function.

\item[time2Vars()] is used only by the net language parser. The
function adds the information about the correspondence of variables
between timeslices to the \cdatatype{Variables}. The procedure must be
executed after all of the \examplecode{node} declarations of the net 
language file have been parsed. It uses the information gathered into the
temporary list created by the \cfunction{add\_time\_init} function.

\item[Graph2JTree()] creates a join tree from the \cdatatype{Graph} made by
the previous functions. This function is to be executed only by the
net language parser. After the \cdatatype{Cliques} (and 
\cdatatype{Sepsets}) have been created, the procedure frees the memory 
used by the graph.

\item[parsedPots2JTree()] is meant to be used only by the net language
parser. The function initialises the cliques created by the previous
functions and uses the \cdatatype{potentials} collected into the temporary
list by the \cfunction{add\_initData} function. Thus the parameters of the
model will be entered into the data structure.

\item[print\_parsed\_stuff()] is meant only for debugging purposes. It
prints the potentials parsed by the net language parser to the
standard output. The function uses the information collected into the 
temporary list by the \cfunction{add\_initData} function.

\item[set\_nip\_statenames(states)] is used only by the net language
parser. It sets a temporary pointer to the \cdatatype{string array}
\cparameter{states}. 

\item[get\_nip\_statenames()] is used only by the net language
parser. It gets the temporary pointer to the \cdatatype{string array}
set by the previous function. 

\item[set\_nip\_label(label)] is used only by the net language
parser. It sets a temporary pointer to the \cdatatype{string}
\cparameter{label}.

\item[get\_nip\_label()] is used only by the net language
parser. It gets the temporary pointer to the \cdatatype{string}
set by the previous function.

\item[set\_nip\_next(next)] is used only by the net language
parser. It sets a temporary pointer to the \cdatatype{string}
\cparameter{next}.

\item[get\_nip\_next()] is used only by the net language
parser. It gets the temporary pointer to the \cdatatype{string}
set by the previous function.

\item[get\_nip\_symbols\_parsed()] returns the number of parent
variables when parsing a \examplecode{potential} declaration of a net
language file. It is meant to be used by the net language parser only.

\item[get\_nip\_strings\_parsed()] returns the number of states when
parsing a \examplecode{node} declaration of a net language file. It is
meant to be used by the net langugage parser only.

\item[get\_num\_of\_cliques()] is to be used for getting the number of
cliques created by the parser. This is one of the functions for
finding out the results of parsing a net language file. (See also the
other functions: \cfunction{get\_cliques\_pointer} and
\cfunction{reset\_Clique\_array}) 

\item[get\_cliques\_pointer()] gets you a pointer to the \cdatatype{array of
cliques} created by the net language parser. (I.e. the returned value
is a \cdatatype{Clique**})

\item[reset\_Clique\_array()] resets the net language parser so that
it can read more net language files. Call this function after you have
discovered the number and location of cliques. Freeing the memory
allocated by the join tree created by the parser is up to the user: 
just use the \cfunction{free\_Clique} function for every clique in the array
when the join tree becomes useless.

\end{description}


\subsection{Other possibilities}

How the stuff could work also...


\newpage
\section{The timeslice handler} % Some system which handles time series?
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}

The interface + how the stuff works...

\subsection{Other possibilities}

How the stuff could work also...



\newpage
\chapter{System analysis}
% The cost of using it
\section{The parser}

\section{The graph}
The underlying assumptions with the \cdatatype{Graph} have been the following:
\begin{enumerate}
\item The graphical analysis step will only be run once per graph.
\item The number of variables in a graph will be relatively small.
\end{enumerate}



\section{The join tree}

\section{The timeslice-monster}


\newpage
\chapter{Comments}


\newpage
%\appendix
%\newpage
\bibliography{dokumentaatio}

\end{document}
