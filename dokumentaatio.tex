% NIP - project documentation
% Mikko Korpela, Antti Rasinen, Janne Toivola 2004
% $Id: dokumentaatio.tex,v 1.23 2004-09-20 14:18:54 arasinen Exp $

\documentclass[12pt,a4paper]{report}
\bibliographystyle{unsrt}
\setlength{\topmargin}{0mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\textheight}{22cm}
\setlength{\textwidth}{16cm}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{tocbibind}
\usepackage{fancyvrb}
%\newcommand{\argmax}{\mathrm{argmax}}
%\newcommand{\argmin}{\mathrm{argmin}}
%\newcommand{\define}{\stackrel{\mathrm{def}}{=}}


% Reminder about the style so far: 
% - C data types     {\it unsigned long}
% - code examples    \verb+this = is_an(example);+
% - file names       \verb+filename.txt+
% - defined stuff    \textbf{A_DEFINED_VALUE}
% - parameter names  \textbf{parameter}
% ...
% Try to keep it consistent...

\newcommand{\cdatatype}[1]{{\it #1}}
\newcommand{\examplecode}[1]{\verb+#1+}
\newcommand{\cfilename}[1]{\verb+#1+}
\newcommand{\cdefine}[1]{\textbf{#1}}
\newcommand{\cparameter}[1]{\textbf{#1}}


%--------------------
% Place this in the preamble of your LaTeX file:
% (c) Jaakko Hollmen, 2002

\usepackage{ifthen}

% Declare the variable doublespaced
\newboolean{doublespaced}

% Comment one of the following lines to either select
% doublespaced or singlespaced:
\setboolean{doublespaced}{false}
%\setboolean{doublespaced}{true}

\ifthenelse{\boolean{doublespaced}}
{
  % Double spaced text if variable "doublespaced" is true:
  \renewcommand{\baselinestretch}{1.5}
  \normalsize % necessary to execute the previous thing
}
{
  % This is to be executed if doublespace is false:
  % else = do nothing
}
%--------------------

\title{NIP}
\author{Antti Rasinen}
\author{Mikko Korpela 54919L}
\author{Janne Toivola 55173U}
\begin{document}

\pagestyle{empty}
\setlength{\parindent}{0mm}
\setlength{\parskip}{3mm}

\large
\textbf{The NIP project}\\

\vspace{45mm}

\begin{centering}
\huge
\textbf{System description}\\ % Any better names for this?
\end{centering}

\parbox{5cm}{\ }
\parbox{1em}{\vskip8cm}

\normalsize
\vspace{5mm}
\begin{tabbing}
The Team:\= Antti Rasinen\\
         \> Mikko Korpela\\
         \> Janne Toivola\\
\vspace{5mm}

\end{tabbing}
%----------------------
Date: \today
%----------------------
\eject\newpage

\pagestyle{plain}

\tableofcontents

%\newpage
%
%\listoffigures


\newpage
\chapter{General description}
This document describes a software library developed by 
the authors at the laboratory of computer and information science at 
Helsinki University of Technology. The software library provides...
% What?


\section{Overview}
Some outline of the system... The parts and stuff...
% How?



\newpage
\chapter{Subsystem descriptions}
% The nasty details
\section{Variables}
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}

\subsubsection{The data structure}
The data type {\it Variable} defined in \verb+Variable.h+ is a pointer 
to a struct which has the following fields: 
\begin{description}
\item[symbol] is a short string used for identifying the variable. Maximum
length is defined as \textbf{VAR\_SYMBOL\_LENGTH} in
\verb+Variable.h+. To ensure the correct operation of the system, the 
symbol should be unique.
\item[name] is a little longer name to describe the variable: it is
called {\it label} in the Hugin net language files. This is NOT used for 
identification of the variables and it doesn't need to be unique. 
The maximum length is defined as \textbf{VAR\_NAME\_LENGTH} in 
\verb+Variable.h+.
\item[statenames] is an array of strings containing names for all
possible states of the variable. The identification of data relies on
these strings. The size of the statenames array i.e. number of
strings should be the same as the number of states indicated by
cardinality field described below.
\item[cardinality] is a positive integer which tells how many states
the variable can have. It plays an important role in all calculations
so it better be correct: the value is not meant to be altered.
\item[id] is an {\it unsigned long} used for identification inside the
system. It is set automatically by the \verb+new_variable+ function
and should not be tampered after that.
\item[likelihood] is a {\it double} array describing the probability
distribution of the states of the variable. It is used only for
entering evidence into the system and likelihood arrays of the latent
variables remain filled with ones. Size of the array equals
cardinality, of course.
\item[previous] is used for describing the repetitive structure in
timeslice models. It is a pointer to the variable which this variable
will replace in previous timeslice. The pointer is {\it NULL} if the
model has no repetitive structure.
\item[next] is a same kind of pointer as \textbf{previous} above, but
this one tells which variable will be replaced in the next timeslice.
The \textbf{previous} and \textbf{next} pointers should be symmetrical
i.e. if \verb+a->next == b+ then \verb+b->previous == a+.
\end{description}

\verb+Variable.h+ provides also data types for implementing lists of
variables. Both \verb+varlink+ and \verb+Variable_iterator+ are
pointers to structs which contain following fields:
\begin{description}
\item[data] is the variable (i.e. pointer to a variable struct) 
contained by the list element.
\item[fwd] is a pointer to the next element in the list or {\it NULL}
at the end of the list.
\item[bwd] is a pointer to the previous element in the list or 
{\it NULL} at the beginning of the list.
\end{description}
Variable iterators are meant to be used the same way as list iterators
in Java: you can get the next element contained by the list by just 
calling \verb+next_Variable(iterator)+. On the other hand, iterators
are NOT meant to be the only reference to a list because it will
advance in the list, pointing always to the next element and eventually
be a null pointer.


\subsubsection{The functions}
The functions provided in \verb+Variable.c+ are
%The interface + how the stuff works...
\begin{description}
\item[new\_variable(symbol, name, states, cardinality)] creates a
variable identified with the \textbf{symbol} string. The \textbf{name} 
string will be copied as the name field of the new variable. Both the 
\textbf{symbol} and \textbf{name} strings may be truncated to the 
allowed length. The states of the new variable will be named according 
to the given string array \textbf{states}. All the given strings are 
copied, so remember to free them after they become useless.
\item[copy\_variable(v)] returns an exact copy of the
variable~\textbf{v}. Note that also the id~field is copied and 
consequently there may not be two copies of the same variable in the 
same model.
\item[free\_variable(v)] frees the memory allocated for the
variable~\textbf{v}. 
\item[equal\_variables(v1, v2)] returns 0 if either of the variables
are null. Otherwise it will tell if the variables have equal id fields
or not.
\item[get\_id(v)] will return the unsigned long id field of the 
variable~\textbf{v}.
\item[get\_symbol(v)] returns the symbol of the variable~\textbf{v}. It
will not make a copy of the string so don't mess with it.
\item[get\_stateindex(v, state)] tells the place of the string
\textbf{state} in the state name array of the
variable~\textbf{v}. This index can be used for interpreting various
arrays describing probability distributions. 
\item[total\_num\_of\_vars()] is used only for aiding the Hugin net 
language file parser to return the total number of newly created 
variables. All the variables created with \textbf{new\_variable} are 
accumulated in a list and this function can tell the size of that list.
\item[get\_first\_variable()] gives the first element in the list
of newly created variables mentioned above.
\item[get\_last\_variable()] gives the last element in the list
of newly created variables mentioned above.
\item[reset\_Variable\_list()] will replace the list of recently created
variables with {\it NULL} and set the size of the list to zero. This
is used only for resetting the list after copying the list pointer
to a new model. Otherwise all the models would share the same list of
parsed variables.
\item[next\_Variable(it)] will give the next variable pointed by the
variable iterator~\textbf{it} and advance the pointer to the next
variable in the list. The function returns {\it NULL} if the iterator
runs out of variables.
\item[get\_parser\_variable(symbol)] aids the net language parser 
to find a variable, identified by the \textbf{symbol} string, in the 
list of newly created variables.
\item[get\_variable(it, symbol)] searches the
variable iterator~\textbf{it} for a variable identified by the string
\textbf{symbol}. The iterator will be used by the function, so it will
not be pointing to the beginning of any lists anymore.
\item[update\_likelihood(v, likelihood)] will set the likelihood array
of variable~\textbf{v} according to the given double array 
\textbf{likelihood}. Size of the given array should be the same 
(or more) than the cardinality of the variable.
\item[reset\_likelihood(v)] fills the likelihood array of the
variable~\textbf{v} with ones. This means that the likelihood of the
variable states will be uniform.
\item[number\_of\_values(v)] returns the cardinality of the
variable~\textbf{v}. It is the exact number of states the variable has
and will always have.
\end{description}


\subsection{Other possibilities}
The Hugin net language parser is made with Bison and consequently the 
\verb+yyparse+ function is not able to return a list of variables etc. 
This makes it awkward to pass the results of parsing to the rest of the
program. Our solution is to create a list of parsed variables in
\verb+Variable.c+ but it could also be at \verb+parser.c+ in order to
avoid having weird functions like \verb+get_parser_variable+.


\newpage
\section{Graphs}
\subsection{General}

The purpose of the graphical analysis is to find an optimal set of
clusters in the graphical model that has the join tree property. XX

The main steps in this process are moralisation and triangulation. The
triangulation process extracts the cliques used to build the join tree.
 
Put simply, moralisation means that any nodes that have a common child
are connected. Furthermore, all directed links are replaced with
undirected links. The resulting graph is called a {\textit moral
graph}.

This graph is then triangulated. There exist several triangulations
for a given graph; we are interested in a triangulation that is
optimal in the sense of adding the least edges\footnote{If there is
more than one optimal solution, further constrains may be
introduced. For example, for memory efficiency we prefer the solution
that leads to the smallest potential tables.} to the moral
graph. Finding such a triangulation is an NP-hard problem, but there
exist heuristics that give nearly optimal results.

The triangulation algorithm is the one presented in ... 

The \cdatatype{Graph} is implemented via an adjacency graph. The
interface is designed to hide the implementation details. The Heap
datatype used in the triangulation stage contains a Graph-like
datatype and could possibly be refactored.


\subsection{The functionality description}
%The interface + how the stuff works...
\subsubsection{The data structures}
The data type \cdatatype{Graph} defined in \cfilename{Graph.h} is a
struct which has the following fields:
\begin{description}
\item[adj\_matrix] is an $n\times n$ adjacency matrix for the
graph. The size $n$ is specified when the graph is first constructed
and it is stored in the variable \cparameter{size}. The matrix is
implemented as a simple array. For this reason it is manipulated via
the macro \cparameter{ADJM}.
\item[variables] is an array of variables associated with this graph.
\item[size] is the number of variables in the Graph.
\item[var\_ind] is an internal array of variables. Used for
performance reasons.
\item[min\_id] The smallest id of a variable associated with the
graph. Used internally for better performance.
\item[max\_id] The largest id of a variable associated with the
graph. Used internally for better performance.
\item[top] is an internal counter used when adding variables. 
\end{description}


\subsubsection{The functions}

The functions provided in \cfilename{Graph.c} are:

\begin{description}
\item[new\_graph(n)] creates a new graph with memory reserved for n
variables. Returns a pointer.
\item[copy\_graph(G)] creates a copy of the graph G.
\item[free\_graph(G)] frees the memory reserved for the graph G.
\item[get\_size(G)] returns the number of variables in the graph G.
\item[get\_variables(G)] returns the variables in the graph G as an array.
\item[get\_graph\_index(G, v)] returns the index of the
variable V in the internal array of the graph G.
\item[get\_neighbours(G, v\_array, v)] returns the number of neighbours
of variable v in graph G. The neighbours will be stored in the array
v\_array, which {\it must be large enough}. No variable can have more
neighbours than $n-1$, where $n$ is the number of variables in G.
\item[is\_child(G, v1, v2)] will return True when variable v2 is a
child of variable v1 in the graph G.
\item[add\_variable(G, v)] adds a new variable v to the graph G. You
must add as many variables as you specified when creating G.
\item[add\_child(G, v1, v2)] adds an edge to graph G from variable v1
to variable v2, ie. makes v2 a child of v1.
\item[find\_cliques(G, cp)] finds cliques in G and stores them
in the clique-array *cp\footnote{Type of cp is Clique**, ie. it is a
pointer to such an array. It need not be initialized.}. Returns the
number of elements in the array.
\item[make\_undirected(G)] returns an undirected copy of Graph G.
\item[moralise(G)] returns a moralised copy of graph G.

\end{description}

\subsection{Notes on Implementation}

The above discussion describes only the interface of the Graph
module. Some data structures used internally by the Graph module are
summarily described here. The explanation is mostly aimed at those
planning to modify the module.

\subsubsection{Heap}

The \cdatatype{Heap} is used to keep the potential cliques in a sorted
data structure. Any search structure would suffice here; the heap is
probably the most officient.

This step requires a dynamically updatable Heap. The weights in
neighbouring nodes change when the minimum weight node is
removed. This also means that the heap implementation must be tied in
with the \cdatatype{Graph}. This has led to number of tradeoffs and
possible pitfalls.

\subsubsection{cls2clq}

The \cdatatype{cls2clq} module is used to convert a list of clusters
to an array of cliques. In addition to a simple list implementation,
it also includes a method to check whether a given set of variables
(ie. a cluster) is a subset of a cluster already in the
list\footnote{There is no need to check for supersets; the items in
the list contain nodes that are then removed from the graph and thus cannot
occur in later clusters.} and a method for the list-to-array
conversion.

The list used in this implementation could be replaced with a generic
list data type.


\subsection{Other possibilities}

From efficiency standpoint, the approach presented in ... is ... and
suitable for production use.

If efficiency is not the main concern, eg. in prototyping situations,
some simplifications can be made. For example, the heap data structure
in the triangulation phase can be replaced with a list or array and a linear
search.

The interface is not as smooth and polished as it could be. It is also
not very flexible. For example you have to know the number of
variables when constructing the graph; the system should be able to
dynamically add new variables 'on the go'. However, such functionality
can be introduced with a wrapper, if desired.


\newpage
\section{Potentials}
\subsection{General}

The idea and mathematical formulas...


\subsection{The functionality description}
%The interface + how the stuff works...
\subsubsection{The data structure}
The data type {\it potential} defined in \verb+potential.h+ is a
pointer to a struct which contains the following fields:
\begin{description}
\item[size\_of\_data] is an {\it integer} telling the total number of 
elements in the potential. It must be the product of all the elements 
in the \textbf{cardinality} array (or one if the number of variables 
equals zero).
\item[cardinality] is an array of {\it integers}. The integers are the
cardinalities of each variable the potential is related to. Thus the
size of the array must be the same as the number of variables. Also
the order of the cardinality array is significant because the
variables are assumed to have a certain order.
\item[num\_of\_vars] is an {\it integer} which tells the number of variables
associated with the potential.
\item[data] is the {\it double array} describing a probability
distribution of the associated variables. The size of this array is in
the \textbf{size\_of\_data} field. The data in the array is arranged
according to the order of the corresponding variables: the variable
which has its cardinality first in the \textbf{cardinality} array is
considered least significant in the sense of placing a value in the
\textbf{data} array. 

\end{description}


\subsubsection{The functions}
The functions provided for manipulating {\it potentials} are placed in
potential.c and are as follows:
\begin{description}
\item[make\_potential(cardinality, num\_of\_vars, data)] creates a
potential struct according to the parameters and returns a pointer
to it. The resulting potential will have its cardinalities of
variables set according to the given \textbf{cardinality} array by
copying the elements in it. The number of associated variables is
given as the integer \textbf{num\_of\_vars}. 

The \textbf{data} parameter can be a null pointer or a {\it double 
array} of the size equal to the product of the cardinalities of the 
variables. In case of a null pointer, the potential will be
initialised to uniform distribution. Otherwise the contents of 
the \textbf{data} array in the potential struct will be copied from
the given \textbf{data} array.
\item[free\_potential(p)] frees the memory allocated for the
potential~\textbf{p}. 
\item[copy\_potential(source, destination)] copies the distribution
contained in the \textbf{source} potential to the given
\textbf{destination} potential. Note that both of the potentials must
be already existent and otherwise equal. Use the 
\textbf{make\_potential} function if you need an entire new copy of 
a potential.
\item[get\_pvalue(p, indices)] retrieves the possibly non-normalised
probability of the configuration of variables, described by the 
{\it integer array} \textbf{indices}, from the potential~\textbf{p}. 
The \textbf{indices} array tells which value each of the associated
variables are assigned: $n-1$ in the array corresponds to the $n$:th 
value of the variable. The \textbf{indices} must be in the same order
as the corresponding variables and their cardinalities in the
potential~\textbf{p}. 
\item[set\_pvalue(p, indices, value)] sets a {\it double}
\textbf{value} in the potential~\textbf{p} the same way as 
\verb+get_pvalue(p, indices)+ retrieves it. (See the description above.)
\item[inverse\_mapping(p, flat\_index, indices)] transforms a
so-called flat index into the {\it integer array} \textbf{indices} according 
to the potential~\textbf{p}. A flat index is an index used for addressing
data in the potential and is therefore an integer between \verb+0+ and 
\verb+p->size_of_data - 1+ inclusive. Shortly, this function is made for
finding out which configuration of states of the variables corresponds
to each element in the potential. Note that the \textbf{indices} array 
is not allocated by the function.
\item[general\_marginalise(source, destination, source\_vars)] is one
of the most useful functions since it computes the marginalisation
i.e. a sum over the variables indicated by the given {\it integer
array} \textbf{source\_vars} and places the result in the given
\textbf{destination} potential. To make any sense, the number of
associated variables in \textbf{source} must be greater than in
\textbf{destination}. The implementation assumes that the variables 
common to the potentials are in the same order. Consequently, all the 
variables in a system must have a total and static ordering in
order to keep all the sets of variables shared by neigbouring clique
potentials in order.

The {\it integer array} \textbf{source\_vars} indicates which
variables are marginalised away. It consists of indices ranging from
\verb+0+ to \verb+source->num_of_vars - 1+ inclusive. The array
must be arranged in ascending order and the size must equal the
difference in the numbers of associated variables in the potentials. 
Simply, a zero in the array tells the function to marginalise over the 
first variable. Note that the result is not normalised.
\item[total\_marginalise(source, destination, variable)] can be used
for finding out the probability distribution of a single variable
according to the \textbf{source} potential. The function is similar to
the \textbf{general\_marginalise} but instead of telling which
variables to marginalise away, the user must indicate which
variable is left unmarginalised. The parameter \textbf{variable} is 
an {\it integer} ranging from \verb+0+ to\\
\verb+source->num_of_vars - 1+ inclusive. Zero indicates the first
variable in the potential.

Another difference arises from the fact that the probability 
distribution of a single variable fits into a one-dimensional array. 
The place to put the resulting {\it double array} 
(\textbf{destination}) is given to the function as one of the
parameters. Size of the array must be equal (or greater) to the
cardinality of the desired variable, so remember to allocate one
before calling this function. Note that the result is not normalised.
\item[update\_potential(numerator, denominator, target, extra\_vars)] 
implements the multiplication of potentials. The function simply
multiplies the elements of the \textbf{target} potential with the
corresponding elements in the \textbf{numerator} potential. At the
same time, the function is able to divide the \textbf{target}
potential with the optional \textbf{denominator} potential. If no
division is needed, \textbf{denominator} can be {\it NULL}.
The \textbf{numerator} and \textbf{denominator} potentials are left
unchanged by the function.

The function is made for multiplying the a clique potential with the 
old and new sepset potentials. It is assumed that the variables
associated with the multiplier potentials are a subset of the
variables associated with the target potential. Thus the user needs to
indicate which of the variables in the target potential are not
associates with the multiplier potentials. This is achieved with the
fourth parameter \textbf{extra\_vars} which is an {\it integer array}. 
The array must be in ascending order. For example, a zero in the array 
indicates that the first variable of the target potential is not
amongst those associated with the multiplicand potentials.
\item[update\_evidence(numerator, denominator, target, var)] is made
for multiplying potentials with probability distributions of a single
variable. The potential to be manipulated is given as the
\textbf{target} parameter. It is multiplied by the given {\it double
array} \textbf{numerator} which usually represents the probability
distribution of a variable. The \textbf{denominator} is a similar 
{\it double array} used for dividing the \textbf{target} potential. 
If not needed, the \textbf{denominator} can be {\it NULL}.

Typically the function is used for multiplying evidence into a clique 
potential and dividing with possible old evidence. The variable, whose 
distribution is to be passed into the potential, must be indicated 
with the \textbf{var} {\it integer}. E.g. a zero tells the function 
that the evidence is about the first variable associated with the potential.
\item[init\_potential(probs, target, extra\_vars)] is essentially the
same as the \\ \textbf{update\_potential} function. It is meant for
multiplying the \textbf{target} potential with the given
\textbf{probs} potential. If the potentials are similar, i.e. they
have the same associated variables, the \textbf{extra\_vars} parameter 
should be {\it NULL}. Otherwise \textbf{extra\_vars} is an 
{\it integer array} indicating which of the variables associated with
the target potential are not associated with the multiplier potential.
\item[print\_potential(p)] is mainly for debugging purposes. It prints 
the contents of the potential~\textbf{p} to the standard output.
\end{description}


\subsection{Other possibilities}
There are several ways of implementing the calculations of the potentials
without keeping the corresponding variables in a certain order. This
could be achieved by using an integer array to remap the order of the
variables instead of telling which are not included and assuming that
the rest of the variables are in the same order in both potentials.


\newpage
\section{Join trees} % Cliques and sepsets
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}
The files \verb+Clique.h+ and \verb+Clique.c+ provide data types and 
functions for operating with sepsets and cliques. Together these form
the concept known as join tree. In the NIP system, a join tree is
merely an array of cliques which in turn have references to all the
necessary sepsets.

\subsubsection{The data structures}
\verb+Clique.h+ provides data types {\it Sepset}, {\it Sepset\_link}, 
and {\it Clique}. {\it Sepset} is a pointer to a struct which has the
following fields:
\begin{description}
\item[old] is older of the two last {\it potentials} passed via the sepset.
\item[new] is the last {\it potential} passed via the sepset.
\item[variables] is an {array of Variables}. These are the variables
associated with the sepset. They are in the same order as their
cardinalities in the potentials \textbf{old} and \textbf{new}. 
The number of the variables can be found in either of the potentials 
\textbf{old} and \textbf{new}.
\item[cliques] is an {array of Cliques}. The references to the
adjacent cliques are there. The size of the array is always two
because of the nature of sepsets.
\end{description}

The data type {\it Sepset\_link} provides an implementation for lists
of {\it Sepsets}. It is a pointer to a struct containing
\begin{description}
\item[data] is a so-called {\it void pointer} because of the order of
definitions. (You can't really define a list of sepsets before you
have defined sepsets. Sepsets can't be defined before cliques and
cliques can't be defined before lists of sepsets.) When the list of
sepsets is used, the \textbf{data} field has to be cast to the 
{\it Sepset} type. 
\item[fwd] is the next {\it Sepset\_link} in the list or {\it NULL} at
the end of the list.
\item[bwd] is the previous {\it Sepset\_link} in the list or 
{\it NULL} at the beginning of the list.

\end{description}

The data type {\it Clique} is a pointer to a struct containing all the
necessary for working with cliques. The fields are
\begin{description}
\item[p] is the clique {\it potential}
\item[original\_p] is the original clique {\it potential} initialised
according to the parameters of the model
\item[variables] is an {\it array of Variables}. These are the
references to the variables associated with the clique. They are in
the same order as their cardinalities in the potential~\textbf{p}.
The number of variables can be found in the potential~\textbf{p}.
\item[sepsets] is a {\it Sepset\_link} i.e. either {\it NULL} or a
list of sepsets. The list contains the references to the adjacent sepsets.
\item[num\_of\_sepsets] is the number of adjacent sepsets.
\item[mark] is an {\it integer} used as a flag by various algorithms. For
example a depth-first search and the propagation of evidence uses the 
\textbf{mark} field to identify the cliques which have already been 
handled.

\end{description}


\subsubsection{The functions}
The file \verb+Clique.c+ provides the following functions
\begin{description}
\item[make\_Clique(vars, num\_of\_vars)] creates a {\it Clique}. The
associated variables are given as the {\it Variable array}
\textbf{vars} and the number of the variables as the {\it integer} 
\textbf{num\_of\_vars}. A shallow copy of the array is made, so
remember to free it (but not the contents). The clique will not have 
any adjacent sepsets initially. Sepsets must be added separately.
\item[free\_Clique(c)] frees the memory allocated by a the 
{\it Clique}~\textbf{c}. It will not free the memory allocated for 
the corresponding {\it Variables}, but all the adjacent {\it Sepsets} 
are freed and removed automatically so that rest of the join tree 
remains valid. Note that freeing an entire join tree can be done by 
calling this function for every clique.
\item[add\_Sepset(c, s)] adds the {\it Sepset} \textbf{s} to the 
{\it Clique}~\textbf{c}. Remember to add the sepset to both adjacent
cliques and never add a sepset to the same clique twice.
\item[make\_Sepset(variables, num\_of\_vars, cliques)] creates a {\it
Sepset}. The associated variables are given as the {\it Variable
array} \textbf{variables} and the size of the array as the {\it
integer} \textbf{num\_of\_vars}. Both adjacent cliques must be given
as an {\it array of Cliques} (\textbf{cliques}). This usually means that
the {\it Cliques} must be created before the {\it Sepsets}.
Note that a shallow copy of the parameter arrays is made, so freeing 
the arrays after calling the function is up to the user.
\item[free\_Sepset(s)] just frees the memory allocated for the {\it
Sepset} \textbf{s}. This is called automatically by
\textbf{free\_Clique} so usually this function is needed only for
freeing possible useless {\it Sepsets} which are not included in the 
join tree.
\item[create\_Potential(variables, num\_of\_vars, data)] can help if
you need to create potentials out of {\it double arrays} like 
the \textbf{data} parameter. The function creates a {\it potential} 
which has its data arranged correcty in order to work with the
system. To rearrange the data correctly, the function needs to know 
the order of the corresponding variables. This is achieved by 
specifying the {\it Variable array} \textbf{variables} and the size 
of it as the {\it integer} \textbf{num\_of\_vars}. 

The most important thing is to have the {\it Variables} array in the 
same order as the \textbf{data} array is thought to be arranged. 
For example, the potentials specified in the Hugin net language have 
the child variable as the least significant one: the value of the variable 
has the least effect on the placement of the data. Thus the child
variable should be the first in the array. Note that for some reason 
the first parent variable specified in the Hugin net language should be 
the last in the \textbf{variables} array, and the last parent should
be the second right after the child variable.
\item[unmark\_Clique(c)] resets the mark in the {\it
Clique}~\textbf{c}. Note that this has to be done for every clique 
before calling \textbf{distribute\_evidence} or 
\textbf{collect\_evidence}.
\item[clique\_num\_of\_vars(c)] tells how many associated variables the 
{\it Clique}~\textbf{c} has.
\item[sepset\_num\_of\_vars(s)] tells how many associated variables the 
{\it Sepset}~\textbf{s} has.
\item[distribute\_evidence(c)] implements the algorithm which spreads 
the evidence entered in to the cliques away from the given 
{\it Clique}~\textbf{c}. See \cite{huang1994} page 21 for
details. 
\item[collect\_evidence(c1, s12, c2)] implements the algorithm which 
collects evidence from the subtree rooted in the given {\it
Clique}~\textbf{c2} and passes the evidence to the {\it
Clique}~\textbf{c1}. The {\it Sepset}~\textbf{s12} is the sepset
between the two cliques. The function is recursive and is usually
used like this: \verb+collect_evidence(NULL, NULL, c);+ where \verb+c+
is some {\it Clique}. This causes the evidence to be collected from
the entire join tree.
\item[initialise(c, child, parents, p)] is used for entering the
quantitative parameters of the model into the join tree. This function
initialises the {\it Clique}~\textbf{c} with the given {\it
potential}~\textbf{p}. The initialisation ensures that the parameters
are not reset by the \textbf{global\_retraction} function. Note
that~\textbf{p} should be a valid {\it potential} i.e. the data
contained by it should be correctly arranged and the number of
variables specified in it should equal to the number of parent
variables plus one (the child).

Since the clique to be initialised can be associated with more
variables than are associated with the potential, the user must
specify the \textbf{child} {\it Variable} and the {\it array of 
variables} which contain the \textbf{parents}. The order of the
variables in the \textbf{parents} array is not relevant and the 
array is not needed after the function has executed.
\item[marginalise(c, v, r)] is one of the most useful functions
because it finds out the probability distribution of the {\it
Variable}~\textbf{v} according to the {\it Clique}~\textbf{c} and
writes it into the {\it double array}~\textbf{r} (as in
\textbf{r}esult). The array must be allocated before the function is
called and the size must be at least \verb+v->cardinality+. 
Note that the result is NOT normalised.
\item[normalise(result, array\_size)] simply normalises the {\it
double array} \textbf{result}. After the function has executed, sum of
the elements in the array will be one, unless it's filled with zeros. 
If the array is full of zeros, it is left unchanged. The size of the
array must be specified as the {\it integer} \textbf{array\_size}.
\item[global\_retraction(vars, cliques, num\_of\_cliques)] resets the 
clique potentials to the state they had after the initialisation and 
enters the most recent evidence into the cliques. Thus the join tree
consisting of the cliques is left at an inconsistent state and you may
want to execute the global propagation consisting of 
\textbf{collect\_evidence} and \textbf{distribute\_evidence}. 

This function is needed for retracting evidence in some cases. To
achieve this, the user must enter the wanted evidence into the
variables and run \textbf{global\_retraction}. The 
{\it Variable\_iterator} \textbf{vars} (list of all the variables) and 
a {\it Clique array} \textbf{cliques} must be specified. Also the
number of the cliques has to be given to the function as the {\it
integer} \textbf{num\_of\_cliques}.
\item[enter\_observation(vars, cliques, num\_of\_cliques, v, state)] 
is made for incorporating hard evidence into a join tree. The observed
state of the {\it Variable}~\textbf{v} is given as a {\it string} named
\textbf{state}. The function needs also the {\it Variable\_iterator}
\textbf{vars}, {\it Clique array} \textbf{cliques} and the size of it
as the {\it integer} \textbf{num\_of\_cliques}. The reference
\textbf{vars} to the list of all variables is needed because of the
possible global retraction. The function \textbf{global\_retraction}
is called automatically if needed.
\item[enter\_i\_observation(vars, cliques, num\_of\_cliques, v, index)]
is made for entering an observation as an {\it integer} into a join
tree. This is equal to the function \textbf{enter\_observation} but
instead of telling the observation as a string, the user should encode
the observation as the {\it integer} \textbf{index}. A zero
corresponds to the first state of the variable defined in the Hugin
net language file. (See the \textbf{get\_stateindex} function also.)
\item[enter\_evidence(vars, cliques, num\_of\_cliques, v, evidence)]
is made for entering soft evidence into a join tree. (Note that hard
evidence is only a special case of soft evidence.) The function is
similar to the \textbf{enter\_observation} and
\textbf{enter\_i\_observation} functions above but instead of
describing a single state, the user must specify a probability
distribution as the {\it double array} \textbf{evidence}. The array is
assumed to be normalised.
\item[find\_family(cliques, num\_of\_cliques, variables, num\_of\_vars)]
tries to find a {\it Clique} which contains all the variables (or
more) specified in the {\it Variable array} \textbf{variables}. The 
number of variables has to be given as the fourth parameter 
\textbf{num\_of\_vars}. The function returns {\it NULL} if there are
no suitable cliques in the specified {\it array of Cliques} 
(\textbf{cliques}) within the given size \textbf{num\_of\_cliques}.
\item[find\_sepsets(cliques, num\_of\_cliques)] creates and inserts 
the sepsets between the {\it Cliques} specified in the array 
\textbf{cliques}. The size of the array must be given as the 
{\it integer} \textbf{num\_of\_cliques}. This function is meant to be
used only once after all of the cliques have been created. 
Consequently, it is not intended for repairing partially created 
join trees.
\item[print\_Clique(c)] is meant for debugging purposes. It prints the
symbols of the variables associated with the {\it Clique}~\textbf{c}
to the standard output.
\item[print\_Sepset(s)] is meant for debugging purposes. It prints the
symbols of the variables associated with the {\it Sepset}~\textbf{s}
to the standard output.
\item[clique\_intersection(cl1, cl2, vars, n)] finds out which
variables are common to the specified {\it Cliques}~\textbf{cl1}
and~\textbf{cl2}. The parameter \textbf{vars} is a {\it pointer to an
array of Variables} and the array will contain the found variables 
after the execution. The size of the array is written to the place 
pointed by the {\it integer pointer}~\textbf{n}. The resulting array
is allocated by the function and it should be freed by the user.

\end{description}


\subsection{Other possibilities}

How the stuff could work also...


\newpage
\section{The Hugin net language parser}
\subsection{General}

% The structure of net files

\subsection{The functionality description}
The parser, for reading models from Hugin net language files, is
written in two files: \verb+huginnet.y+ contains the lexer and 
description of the language for the Bison parser generator and 
\verb+parser.c+ contains lots of helper functions for the parser. 
The data structures used for parsing are defined in the
\verb+parser.h+ file. There's also a file named \verb+fileio.c+ which 
contains functions for tokenising the lines read from files.

\subsubsection{The data structures}
The \verb+parser.h+ file defines several data types used with the
parser implementation. One of them is {\it doublelink} which is a
pointer to a struct which can hold a {\it double} and consequently
form a list of floating point numbers. The struct contains the
following fields
\begin{description}
\item[data] is the {\it double} number contained by the list element.
\item[fwd] is a {\it doublelink} i.e. a pointer to the next element in
the list or {\it NULL} at the end of the list.
\item[bwd] is a {\it doublelink} i.e. a pointer to the previous element in
the list or {\it NULL} at the beginning of the list.
\end{description}

Another kind of useful data type is {\it stringlink} which is a
pointer to a struct. The struct can be used as an element in a list of
strings. The element contains the following fields
\begin{description}
\item[data] is the {\it string} i.e. an array of characters.
\item[fwd] is a {\it stringlink} i.e. a pointer to the next element in
the list or {\it NULL} at the end of the list.
\item[bwd] is a {\it stringlink} i.e. a pointer to the previous element in
the list or {\it NULL} at the beginning of the list.
\end{description}

Since the conditional probability distributions and the structure of
the model are both encoded into the \verb+potential+ declarations of
the net language, the distributions have to be temporarily stored until
the entire net file has been parsed and the join tree is made. In
other words, you can't enter the quantitative parameters of the model
until you know the qualitative structure of it. This is why the parser
stores all the {\it potentials} read from the net file into a list
until the end of parsing. This is where the data type 
{\it initDataLink} comes handy. It is a pointer to a struct which
holds the following fields
\begin{description}
\item[data] is the {\it potential} stored by the list element.
\item[child] is the {\it Variable} which was defined to depend on
other variables in the potential declaration of the net language.
\item[parents] is an {\it array of Variables} which contains the
parent variables of the \textbf{child}. Instead of an array it may be
{\it NULL} if the \textbf{child} was an independent variable and had
no parents.
\item[fwd] is a pointer to the next element in the list or {\it NULL}
at the end of the list.
\item[bwd] is a pointer to the previous element in the list or {\it NULL}
at the beginning of the list.
\end{description}

A same kind of problem arises with the \verb+node+ declarations of the
Hugin net language when timeslices are defined. The parser can't assign
the pointer from a {\it Variable} to the corresponding {\it Variable}
in the next timeslice before both of the variables have been
parsed. This is solved by collecting the information about timeslice 
dependencies into a list until all the variables have been read from
the net file. The file \verb+parser.h+ defines a data type for this
purpose: {\it time\_init\_link} is a pointer to a struct which can be
used as an element in a linked list and holds the following fields
\begin{description}\item[var] is the {\it Variable} which corresponds
to another one in the next timeslice.
\item[next] is the symbol {\it string} which identifies the corresponding 
variable in the next timeslice.
\item[fwd] is a {\it time\_init\_link} i.e. a pointer to the next
element in the list or {\it NULL} at the end of the list.
\end{description}

There's also a small parser for the data files. A data type has been
defined for reading timeseries data from files. The data type 
{\it datafile} is a struct which contains the following fields
\begin{description}
\item[name] is a string ({\it char array}) which contains the 
name of the file.

\item[separator] is the character (a single {\it char}) which is used 
as the separator between elements on a row in the data file.

\item[file] is a file handle of the type {\it FILE}.

\item[is\_open] is an {\it integer} telling whether the file is open
or not.

\item[firstline\_labels] is an {\it integer} which indicates whether
the first line of the data file contains node labels of the
corresponding variables or not. 

\item[line\_now] is an {\it integer} which tells the current position
in the file.

\item[datarows] is an {\it integer} telling the number of data rows in
the file i.e. the length of a timeseries. If there's a line containing
the node labels in the beginning of the file, it is not counted as a
data row.

\item[node\_symbols] is an {\it array of strings}. It contains the
symbols (short names) of the observed variables. These are usually
found on the first line of the data file.

\item[num\_of\_nodes] tells the number of the observed variables as an
{\it integer}.

\item[node\_states] is a {\it two-dimensional array of strings}. It
contains the names of the states of every observed variable. For
example \verb+node_states[i][j]+ is a name of a state of the $i:th$
observed variable, assuming that $j \in [0, c-1]$, where $c$ is the 
cardinality of the variable. This array is particularly useful if the
model is created automatically from data and not read from a net file.

\item[num\_of\_states] is an {\it array of integers} which tells how
many different states corresponding observed variable has had in the
data file.
\end{description}


\subsubsection{The functions}
The file created by Bison, \verb+huginnet.tab.c+, contains the
function which starts the Hugin net language file parser for reading a model
from a file.
\begin{description}
\item[yyparse()] must be included as an {\it external} function. 
(like \verb+extern int yyparse();+) It is the function which causes 
a model being parsed from a file. Use the helper functions at 
\verb+parser.c+ to open the net language file prior to parsing, to close it
after the execution and to dig out the newly created
model.
\end{description}

For the sake of completeness, the lexer is described too. The file 
\verb+huginnet.y+ contains the following function
\begin{description}
\item[yylex()] is used only by the parser created with Bison parser
generator. The function reads tokens from the input file, recognises
them and passes them to the parser appropriately.
\end{description}
It uses extensively the helper functions found in
\verb+fileio.c+. These are as follows
% fileio.c
\begin{description}
\item[count\_words(s, chars)] returns the number of words in the 
{\it string}~\textbf{s}. The words are separated by white space and
\textbf{s} must be null terminated. If the {\it integer pointer}
\textbf{chars} is not a null pointer, the number of characters
in~\textbf{s} written there.

\item[count\_tokens(s, chars, q\_strings, separators,
n\_separators, sep\_tokens, wspace\_sep)] counts the number of
tokens in the null terminated {\it string}~\textbf{s}. The result is
returned as an {\it integer}. The number of characters in the string
is written to the integer referenced by the {\it integer pointer}
\textbf{chars}. 

Rest of the parameters make the function extremely versatile. The 
{\it integer} \textbf{q\_strings} indicates whether possible
substrings enclosed in double quotes ('') should be considered as
single tokens or not. The {\it character array} \textbf{separators} 
may be used for specifying additional separators. Each character in the 
array behaves as a separator. A white space is always a separator. The
number of the additional separators must be specified as the {\it
integer} \textbf{n\_separators}.

The {\it integer} \textbf{sep\_tokens} is used as a flag to indicate
whether the separators themselves should be considered as tokens or
not. Finally, the {\it integer} \textbf{wspace\_sep} indicates whether
white space should be considered as a separator token or just a plain 
separator.

\item[tokenise(s, n, q\_strings, separators, n\_separators, 
sep\_tokens, wspace\_sep)] is the tool for finding \textbf{n} first 
tokens in the null terminated {\it string}~\textbf{s}. The function 
returns an {array of integers} which tells where each token begins 
and where they end. The first integer in the array tells which
character in the string begins the first token. The second
integer tells the place of the first character NOT included in the
first token. The third and fourth integers tell the placement of the
second token and so on.

Rest of the parameters are similar to the ones in the 
\textbf{count\_tokens} function. The {\it integer} \textbf{q\_strings}
indicates whether we want quoted strings to be single tokens or
not. The {\it character array} \textbf{separators} specify separators
in addition to white space and the {\it integer}
\textbf{n\_separators} tells the number of additional separators. The
{\it integer} \textbf{sep\_tokens} indicates whether we want the
separators to be tokens as well. If the {\it integer}
\textbf{wspace\_sep} is not zero, the white space will behave as
separator but will not be considered as a token even if the other
possible separators are.

\item[split(s, indices, n)] uses the {\it integer array}
\textbf{indices} (made by the \textbf{tokenise} function) to split the
null terminated {\it string}~\textbf{s} into \textbf{n} strings. 
The function returns the strings as an array. ({\it char**} i.e. an
array of character arrays)
\end{description}


Most of the actions executed by the net language file parser is done by the
functions in \verb+parser.c+. The functions are as follows
\begin{description}
\item[open\_yyparse\_infile(filename)] is one of the most important
functions in reading models from files. It opens a file for the parser
for reading and returns zero if the file was opened successfully. The 
name of the file is given as the {\it string} \textbf{filename}.

\item[close\_yyparse\_infile()] should be called after parsing a model
from a file. It closes the net language file appropriately.

\item[open\_datafile(filename, separator, write, nodenames)] is used
for opening data files for reading or writing. The function returns a 
pointer to the created {\it datafile} struct. The name of the data
file is given as the {\it string} \textbf{filename} and the used
separator is given as the {\it character} \textbf{separator}. The 
{\it integer} \textbf{write} is used for indicating whether the file
should be opened for reading only (zero) or for writing only
(non-zero). The {\it integer} flag \textbf{nodenames} tells the 
function to treat the first line of the file as regular data (zero) or
use the tokens on the line as the symbols of the variables. If 
\verb+nodenames == 0+ the function invents its own symbols for the
variables to be included with the {\it datafile} struct.

\item[close\_datafile(file)] closes the data file included in the
given {\it datafile pointer} \textbf{file} and frees the memory
allocated for the {\it datafile} struct.

\item[nextline\_tokens(f, separator, tokens)] is the function made for
reading data files. It reads the next line of the {\it datafile}
referenced by the pointer~\textbf{f} and splits the line into
tokens. The separator should be specified as the {\it character}
\textbf{separator}. The function returns the number of tokens as an 
{\it integer} and sets the pointer \textbf{tokens} to reference the
resulting {array of strings}. I.e. \textbf{tokens} is a pointer to an
array of character arrays, or in other words a \verb+char***+. Make
sure that you don't lose any existing pointers by calling this
function, because freeing the tokens read from the file is up to the 
user.

\item[next\_token(token\_length)] is used by the net language
parser. The function returns the next token from the opened net file
and writes the length of the token to the {\it integer} referenced by
the pointer \textbf{token\_length}. The token is a (null terminated)
{\it string} i.e. an array of characters. The token length does not
include the NULL character and equals zero if there are no more tokens
in the file. After the token string has been used, please free the
memory allocated for it.

\item[add\_symbol(v)] is used only by the net language parser. The
function adds the {\it Variable}~\textbf{v} into a temporary list of
parent variables. The list is needed for parsing the parent variables
according to the potential declarations of the net language. (See also
the \textbf{make\_variable\_array} function)

\item[add\_initData(p, child, parents)] is used only by the net
language parser. This function adds the parsed 
{\it potential}~\textbf{p}, the {\it Variable} \textbf{child} and its
\textbf{parents} in an {\it array of Variables} to the list of parsed
potentials. The potentials are collected into the list until the
join tree has been created and it can be initialised with the potentials.

\item[add\_time\_init(var, next)] is used only by the net language
parser. It adds information about the correspondence of nodes between
timeslices into a temporary list. The {\it Variable} \textbf{var} will
correspond to the {\it Variable} identified by the symbol {\it string}
\textbf{next} in the next timeslice. The information has to be
collected into a list, because the another variable may haven't been
created yet at the moment. After the variables have been parsed, the
list is cleaned.

\item[add\_double(d)] is used only by the net language parser. The
function adds the {\it double}~\textbf{d} into a temporary list of
floating point numbers. Usually the list is used for storing the
numbers of the data fields of the potential declarations in the net
files. The list can be turned into an array by the
\textbf{make\_double\_array} function.

\item[add\_string(string)] is used only by the net language
parser. Calling this function will add the null terminated {\it array
of characters} \textbf{string} into a temporary list. The list is used
for storing the names of the states declared in the node declarations
of the net language. The list can be turned into an array by using the
\textbf{make\_string\_array} function.

\item[make\_variable\_array()] is used only by the net language
parser. The function creates an array containing the {\it Variables}
accumulated in the temporary list by \textbf{add\_symbol}
function. The resulting array is usually used as the array of parent 
variables.

\item[make\_double\_array()] is used only by the net language
parser. It creates an {\it array of doubles} containing the numbers
accumulated into the temporary list by the the \textbf{add\_double}
function. The array is used as the data for the parsed potentials. 

\item[make\_string\_array()] is used only by the net language
parser. The function creates an {\it array of strings} out of the list
created by the \textbf{add\_string} function. The array is used as the
statename array of the parsed variables.

\item[reset\_doubles()] cleans the temporary list of floating point
numbers created with the \textbf{add\_double} function. The function
should be used only by the net language parser.

\item[reset\_strings()] cleans the list of {\it strings} gathered with
the \textbf{add\_string} function. This function does NOT free the
actual strings, only the list structure. The function is meant to be
used only by the net language parser.

\item[reset\_symbols()] cleans the temporary list of variables made by
the \textbf{add\_symbol} function. The function does NOT free the
actual {\it Variables}, only the list structure itself. It is meant to
be used only by the net language parser.

\item[reset\_initData()] cleans the data used for initialising the
join tree. The function also frees the {\it potentials} and the arrays of
parent {\it Variables} gathered in the list. (The variables themselves
are not freed, of course.) The function is meant to be used only by
the net language parser.

\item[reset\_timeinit()] cleans the temporary list about the timeslice
correspondencies accumulated by the \textbf{add\_time\_init} function.
Only the list structure and the stored symbol string are freed, not
the referenced variables. The function is meant to be used only by the
net language parser.

\item[init\_new\_Graph()] is meant to be used only by the net language
parser. The function initialises a new {\it Graph} which can hold as
many variables than is parsed from the file so far.

\item[parsedVars2Graph()] executes one stage in the net language
parser. It inserts the {\it Variables} into the initialised {\it
Graph} after all of the variables have been created. The function adds
also the child-parent relation to the {\it Graph}. Therefore it
must be called after all of the \verb+potential+ declarations of the
net file have been parsed and the information can be found from the
initialisation list accumulated by the \textbf{add\_initData}
function.

\item[time2Vars()] is used only by the net language parser. The
function adds the information about the correspondence of variables
between timeslices to the {\it Variables}. The procedure must be
executed after all of the \verb+node+ declarations of the net language
file have been parsed. It uses the information gathered into the
temporary list created by the \textbf{add\_time\_init} function.

\item[Graph2JTree()] creates a join tree from the {\it Graph} made by
the previous functions. This function is to be executed only by the
net language parser. After the {\it Cliques} (and {\it Sepsets}) have 
been created, the procedure frees the memory used by the graph.

\item[parsedPots2JTree()] is meant to be used only by the net language
parser. The function initialises the cliques created by the previous
functions and uses the {\it potentials} collected into the temporary
list by the {\it add\_initData} function. Thus the parameters of the
model will be entered into the data structure.

\item[print\_parsed\_stuff()] is meant only for debugging purposes. It
prints the potentials parsed by the net language parser to the
standard output. The function uses the information collected into the 
temporary list by the {\it add\_initData} function.

\item[set\_nip\_statenames(states)] is used only by the net language
parser. It sets a temporary pointer to the {\it string array}
\textbf{states}. 

\item[get\_nip\_statenames()] is used only by the net language
parser. It gets the temporary pointer to the {\it string array}
set by the previous function. 

\item[set\_nip\_label(label)] is used only by the net language
parser. It sets a temporary pointer to the {\it string}
\textbf{label}.

\item[get\_nip\_label()] is used only by the net language
parser. It gets the temporary pointer to the {\it string}
set by the previous function.

\item[set\_nip\_next(next)] is used only by the net language
parser. It sets a temporary pointer to the {\it string}
\textbf{next}.

\item[get\_nip\_next()] is used only by the net language
parser. It gets the temporary pointer to the {\it string}
set by the previous function.

\item[get\_nip\_symbols\_parsed()] returns the number of parent
variables when parsing a \verb+potential+ declaration of a net
language file. It is meant to be used by the net language parser only.

\item[get\_nip\_strings\_parsed()] returns the number of states when
parsing a \verb+node+ declaration of a net language file. It is meant
to be used by the net langugage parser only.

\item[get\_num\_of\_cliques()] is to be used for getting the number of
cliques created by the parser. This is one of the functions for
finding out the results of parsing a net language file. (See also the
other functions: \textbf{get\_cliques\_pointer} and
\textbf{reset\_Clique\_array}) 

\item[get\_cliques\_pointer()] gets you a pointer to the {\it array of
cliques} created by the net language parser. (I.e. the returned value
is a {\it Clique**})

\item[reset\_Clique\_array()] resets the net language parser so that
it can read more net language files. Call this function after you have
discovered the number and location of cliques. Freeing the memory
allocated by the join tree created by the parser is up to the user: 
just use the {\it free\_Clique} function for every clique in the array
when the join tree becomes useless.

\end{description}


\subsection{Other possibilities}

How the stuff could work also...


\newpage
\section{The timeslice handler} % Some system which handles time series?
\subsection{General}

The idea and mathematical formulas...

\subsection{The functionality description}

The interface + how the stuff works...

\subsection{Other possibilities}

How the stuff could work also...



\newpage
\chapter{System analysis}
% The cost of using it
\section{The parser}

\section{The graph}

\section{The join tree}

\section{The timeslice-monster}


\newpage
\chapter{Comments}


\newpage
%\appendix
%\newpage
\bibliography{dokumentaatio}

\end{document}
